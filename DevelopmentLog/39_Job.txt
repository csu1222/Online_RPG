
이제 Job 이라는 일감을 Queue에 담아 가능한 쓰레드에서 처리하도록 하는 

커맨드 패턴을 적용할것입니다. 

커맨트 패턴을 적용하지 않으면 일감을 하나의 쓰레드에 담당시켜 처리하도록 해야하는데 그렇게 하면 한번에 많은 일감이 생겼을때 
락이 걸렸을경우 병목현상이 일어납니다. 

지금 코드에서 패킷을 처리하는 Handle 함수들이 해당 함수내에서 처리를 했는데 그 대신 JobQueue에 넣고 나오는 식으로 수정하면 될것입니다.

Job이라는 주문서를 만들어 큐에 넣어놓을때 인자를 같이 넣어줘야할 수 있습니다. 어떤 함수와 그 인자를 한번에 넣어놓을때 사용하는게 Functor 였습니다. 

Functor 는 사실 클래스인데 한가지 함수역할을 하는 클래스인데 객체로 만들어 나중에 필요할때 실행할 수 있습니다. 거기에 클래스다보니깐 멤버 변수로 인자를 들고 있을 수 있습니다. 
그래서 함수포인터 보다 좋은점이 인자를 들고 있을 수 있다라는 건데 
비효율적인 점도 있습니다. 
일감의 종류마다 새로 해당 Functor 클래스를 새로 만들어야합니다. 
예를 들어 Login, EnterGame, Spawn 이라는 세가지 패킷이 있다면 이걸 Functor 로 만든다면 각각 하나씩 3개의 Functor 를 만들어야 하는데 
실제 게임은 수많은 패킷들로 이루어져있을 것이기 때문에 그 때 마다 Functor를 만들어야합니다. 

이런 Functor의 단점도 보완한 C++ 문법이 Lambda 입니다. 
람다식이 그냥 익명함수인것이 아니라 캡쳐라는 문법때문에 펑터를 대체 할 수 있는것입니다. 

이 함수를 예로 들겠습니다. 
bool Handle_C_ENTER_GAME(PacketSessionRef& session, Protocol::C_ENTER_GAME& pkt)
{
	// 플레이어를 생성 
	PlayerRef player = ObjectUtils::CreatePlayer(static_pointer_cast<GameSession>(session));

	// 방에 입장
    auto job = [player]()
    {
	    GRoom->HandleEnterPlayerLocked(player);
    }

	return true;
}

이러면 job 이라는 람다식은 player를 복사해 들고 있고 GRoom->HandleEnterPlayerLocked 라는 함수를 실행할 준비가 되었습니다. 

람다식도 단점이 없지는 않은데 위에서 player 라는 인자가 만약 참조값으로 캡쳐해 가지고 있다면 job을 execute 하기 전에 player라는 객체가 소멸한다면 나중에 job을 처리할 때 
엉뚱한 주소에 접근하게 됩니다. 

이 문제를 해결하기 위해서 프로젝트에서 객체들을 모두 스마트포인터로 사용하기로 정하는것입니다. 그러면 참조카운터로 인해 Job 이 참조하고 있는 객체는 소멸하지 않게 됩니다. 

패킷을 커맨드 패턴으로 사용하기 위해서 먼저 패킷을 보면 일감을 사용하는 패킷 핸들 함수를 보면 
Handle_C_ENTER_GAME, Handle_C_LEAVE_GAME, Handle_C_MOVE 입니다 다 Room 의 멤버 함수로 처리를 하고 있는데 이 함수들을 Job 으로 만들려면 
Room을 JobQueue 를 상속받게 하고 JobQueue의 DoAsync를 사용하면 됩니다. 
이러면 DoAsync로 넣은 Job 을 처음으로 넣은 스레드가 처리를 하게 될겁니다. 

이 수정을 하면서 주의해야 할 점은 커맨드 패턴을 쓰기 시작하면 왠만하면 모두 스마트 포인터를 사용해야한다는 점과 
표준 mutex 를 중첩되게 잡으면 크래시가 난다는 점입니다. 

기본 Room::HandleMove 함수에서는 인자로 Protocol::C_MOVE& pkt 를 받았었는데 참조값을 받는것이 스마트 포인터가 아니기 때문에 이정도는 복사 방식으로 처리하도록 합니다. 

그리고 표준 mutex를 중첩되게 사용하지 않기 위해 이전 LockQueue 의 코드중 Pop에서도 락을 잡고 Pop을 활용하는 PopAll 에서도 락을 잡았습니다. 여기에 락없이 Pop을 하는
PopNoLock 이라는 함수를 추가로 만들어 Pop, PopAll 둘다 PopNoLock을 사용하도록 해줍니다. 



지금처럼 JobQueue 를 두고 일감을 처리하면 각 룸에서 나온 일감들을 하나의 큐에 담아서 처리는 하게 되었는데 고정으로 하나의 쓰레드가 처리하지는 않지만 
결국 처리하는 쓰레드는 하나씩 밖에 안됩니다. 이러면 온라인 게임의 패킷들을 모두 처리 할 수 없게 됩니다. 그래서 더 넓은 월드를 가진 게임들은 일을 처리하는 쓰레드들을 여럿 둬서 처리하는 영역을 나눠 
일을 할겁니다. 그런데 영역을 기준으로 쓰레드를 할당하면 온라인 게임에서 한번에 한 필드에 모이는 경우에 일감을 쳐내기가 힘듭니다. 

그래서 다음 방법으로 영역기준으로 쓰레드를 할당하는게 아니라 액터 단위로 쓰레드를 배치하는 방법도 있다고 합니다. 
액터마다 쓰레드를 배치하는 방법으로는 주변의 다른 액터를 서칭할때 가상의 범위를 지정해 서칭해야합니다. 
범위를 지정해 다른 액터들의 정보를 가져온다고 하면 결국 병목현상이 생길 겁니다. 가져온 데이터를 각 쓰레드가 독립적으로 사용할 수 있는 메모리인 TLS에 복사해 사용하는 경우가 있습니다. 
하지만 액터마다 쓰레드를 할당하는 방법도 단점이 있는데 컨텐츠 개발 난이도가 어려워진다라는 겁니다. 

예를 들어 액터마다 쓰레드를 배치한다면 두 액터사이에 공격이 발생해 서로 공격력과 생명력 방어력등을 알아야 한다고 하겠습니다. 룸에서 여러 플레이어를 관리해서 그 플레이어끼리 공격 로직을 진행하면 
룸이 가지고 있는 플레이어들의 체력, 공격력등을 가져와 연산하면 되지만 각 플레이어마다 다른 쓰레드에서 연산중이라면 한쓰레드에서 다른 쓰레드에 데이터를 요청하기 위해 그때마다 Job으로 그 요청을 만들어 
JobQueue에 넣어야합니다. 

