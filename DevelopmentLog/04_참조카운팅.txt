
기본 서버 준비로 CoreTLS, CorePch, CoreMacro, CoreGlobal, Types 등의 준비를 했고 
멀티쓰레드 사용을 위한 Reader-Writer Lock, ThreadManager, DeadLockProfiler 들을 만들어 봤습니다. 

이어서는 이제 메모리 관리를 하기위한 준비를 할것입니다.  
하지만 여기서 배운 내용들을 모두 프로젝트에 적용하지는 않을겁니다. 

메모리 관리의 첫 시작은 스마트 포인터입니다. 

스마트 포인터는 잘 알고 있을겁니다.
생포인터를 사용하다보면 복잡한 코드에서 어떤 객체를 여러곳에서 참조하던중에 어떤 조건에 의해 갑자기 객체가 메모리 해제를해버리게되면 
객체를 참조하고 있던 다른 곳에서는 메모리가 해제된 주소에 접근하게되면서 매우 위험한 상황이 생길 수 있습니다.

그래서 여러곳에서 참조하고 있는 객체는 모든 참조가 끝날때까지 메모리 해제를 하지 않아야 하는데 이것을 Reference Count 참조 카운팅
shared_ptr 이라고 합니다. 

바로 shared_ptr 를 사용하지 않고 참조 카운팅을 하는 방법중에 쉬운 방법 하나는 

최상위 클래스에 참조 카운트를 만들어 두고 그 산하 클래스 끼리의 참조 관계를 추적하는것입니다. 
산하 클래스끼리 참조를 하게 되면 참조한 클래스의 참조카운트를 늘려주고 참조를 끝낼때는 바로 객체를 삭제 하는게 아니라 참조카운트를 줄이고 그 값이 0이 되었을대 
삭제를 진행하는것입니다. 

위의 방식의 문제점은 멀티쓰레드에서는 사용하지 못한다는것입니다. 사용하는 카운트 변수가 아토믹하지 않기 때문인데 그렇다고 카운트 변수만 아토믹으로 만들어 준다고 끝이 아니고
동작하는 함수들의 줄 마다 멀티쓰레드에서는 다른 쓰레드의 간섭이 일어날 수 있습니다. 

이럴때 사용할 수 있는게 스마트 포인터 입니다. 
스마트 포인터에는 weak_ptr, shared_ptr, unique_ptr 세가지를 주로 사용합니다. 
이중에 shared_ptr이 참조 포인터를 관리하면서 가장 자주 사용하는 스마트 포인터입니다. 

shared_ptr는 어떻게 동작하냐면 템플릿을 사용해 객체의 타입을 받아주면서 해당 객체를 포인터로 들고 있다가 
데이터를 세팅할때 참조 카운터를 증가시키고 해제할때는 카운트를 줄어주게 합니다. 