

세션에서 좀 더 다듬어야 할 부분이 있습니다. 

바로 RecvBuffer입니다. 이전에는 그냥 BYTE 배열로 사용하고 있었습니다. 

SendBuffer와 달리 RecvBuffer는 다행히 한번에 하나만 실행이 될겁니다 왜 그러냐면 
실질적으로 RegisterRecv는 ProcessConnect 에서 한번 호출된후 ProcessRecv 에서 계속 다시 호출되기만합니다. 
이렇게 되면 GetQueuedCompletionStatus 에서 통과되는 RecvEvent 는 한세션에서 하나만 통과됩니다. 

그래서 멀티쓰레드 관련 문제에서 좀 더 자유롭습니다. 
그렇다고 해서 그냥 BYTE 배열그대로 사용하는건 문제가 있습니다. 

RegisterRecv에서 WSARecv 를 호출하기 위해서 WSABUF 객체를 만들어 여기에 버퍼와 사이즈를 넣어주고 있는데 

TCP 연결의 특성상 상대방이 보내는 데이터가 100 바이트였다고 해서 받는 입장에서 무조건 100바이트가 왔을거라는 보장이 없습니다. 
TCP 의 특성이 연결지향, 안정된 연결인대신 패킷의 바운더리가 없었습니다. 

이 특성이 문제가 되는 이유는 대부분의 경우 어떤 패킷을 전체를 받아야 그 패킷의 요규하는 처리를 시작할 수 있을겁니다. 
그래서 지금 그냥 BYTE 배열의 버퍼 안에 항상 모든 데이터가 들어왔을거라고 가정하고 처리하면 안된다는것입니다. 

그러면 패킷의 크기를 어떻게 아냐면 나중에 패킷설계를 하면서 가장앞에 패킷 헤더를 붙혀서 이 패킷의 크기를 기입해둘것입니다. 
이런 정보가 있다면 어느 Recv 처리에서 받은 패킷이 완전하지 않은걸 알게 되면 다음 수신을 기다려 패킷을 덧붙혀 완전한 상태에서 다음 
데이터 처리가 들어가야 할것입니다. 

그래서 ServerCore 에 RecvBuffer 클래스 파일들이 추가가 되고 여기서 새로운 기법으로 버퍼를 만들어 보겠습니다. 

어찌됐던 실제 데이터를 담을 컨테이너가 있어야 할텐데 Vector<BYTE> 타입으로 만들어 줄것이고 
이 버퍼의 크기인 _bufferSize 도 멤버 변수로 필요할것이고 여기에 이번에 새로운 기법으로 _readPos, _writePos 라는 int32 타입 멤버 변수를 추가합니다. 

이 _readPos, _writePos 는 커서같은 거라고 볼 수 있는데 처음에는 두 커서 모두 버퍼의 가장앞 인덱스에 위치하게 될것입니다. 
이후 버퍼에 어떤 데이터를 입력하게 되면 그 크기만큼 _writePos 가 이동하게 될것이고 채워진 데이터를 처리하게 되면 _readPos 가 이동하게 될것입니다.

즉, _writePos, _readPos 사이에 있는 데이터가 유효한 데이터인것입니다. 

그런데 어느순간이 되면 버퍼의 가장 끝에 커서들이 도달하면 어떻게 해야 하냐면 
가장 전통적인 방법은 순환 버퍼를 사용하는 것입니다. 순환버퍼라는것은 버퍼의 끝까지 사용하면 버퍼 처음 부분으로 돌아와 다시 작성을 하는 방식입니다. 

또 다른 방법으로 처음부터 버퍼에 여유를 두고 만든 후 버퍼를 사용하다 보면 어느 순간 _readPos 와 _writePos가 딱 겹치는 순간이 오게 될겁니다. 
그 순간에는 이제 기존 버퍼를 모두 사용한 상태라고 할 수 있으니 이 순간 커서들을 모두 버퍼의 0번 인덱스로 이동을 합니다. 
커서만 옮기는 것이다 보니 복사 비용이 들지 않는 방법 입니다. 
혹여 버퍼의 끝까지 갈때 까지 _readPos와 _writePos 가 곂치지 않았다면 일단 _readPos 가 지나온 부분의 버퍼는 모두 사용한 부분일것이니 
두 커서의 간격을 유지한채로 버퍼의 맨앞으로 이동해도 될것입니다. 

이런 형태의 RecvBuffer를 구현하기 위혀 몇가지 기능을 추가할건데 
버퍼를 비우는 Clean, _readPos의 데이터를 처리할 OnRead, _witePos 부터 데이터를 작성할 OnWrite, 현재 읽고 있는 부분의 버퍼위치를 반환하는 ReadPos, 쓰고 있는 부분의 
버퍼 위치를 반환하는 WritePos, 현재까지 버퍼에 담긴 데이터의 크기를 반환하는 DataSize, 버퍼에 남은 사이즈를 반환하는 FreeSize 정도로 
간단하게 만들어  볼것입니다. 

데이터를 복사해야 하는 경우를 아주 간단한 방법으로 좀 더 방지하자면 버퍼를 아예 몇배로 넓게 잡고 길게 시도하다보면 
왠만해서는 _readPos 와 _writePos 가 곂치는 순간이 오게 됩니다. 
그것을 위해 enum 으로 BUFFER_COUNT = 10, 정도 관리를 해서 버퍼배수를 정해두고 입력받은 buffersize 에 곱해서 버퍼를 사이징 하는것입니다. 

BUFFER_COUNT 를 추가한 이후 FreeSize 의 내용을 조금 변경해야하는데 
기존 _bufferSize - _writePos 값을 반환 하고 있던 것을 _capacity - _writePos 로 수정해야합니다. 


멤버 함수들의 좀 더 자세한 내용은 

먼저 생성자에서는 int32 버퍼 사이즈를 인자로 받아 _bufferSize 로 저장하고 여기에 BUFFER_COUNT 만큼 곱해서 _capacity 라는 변수로 실제 버퍼 크기를 관리합니다. 
Vector<BYTE> 였던 _buffer 를 _capacity 만큼 resize 해줍니다. 

소멸자에서는 딱히 하는것은 없습니다. 

Clean 함수는 버퍼를 정리하는 함수로써 만약 운좋게 _readPos, _writePos 가 동일한 좌표에 있다면 버퍼의 처음으로 이동시켜 버퍼를 재사용가능하게 해줄것입니다.
이 경우가 어떤 경우냐면 DataSize() 의 값이 0이라면 커서 둘이 같은 위치에 있다는 것이니 커서를 맨 앞으로 이동가능합니다. 
만약 DataSize() 가 0이 아닌경우 일단 최대한 기다리면서 DataSize() 가 0이 되는 상황을 만드는것이 가장 비용이 적게 들어갑니다.    
불가피하게 데이터를 맨앞으로 옮겨야 하는 상황이라면 ::memcpy 를 통해 버퍼의 0번 인덱스에 &_buffer[_readPos] 부터 DataSize() 만큼을 복사하고 
_readPos는 0 _writepos 는 DataSize() 값으로 두면 됩니다. 
옮겨야 하는 상황은 FreeSize() 의 값이 _bufferSize 보다 작거나 같을 경우로 정하면 적어도 버퍼 하나 크기의 여유를 두고 남아 있는 데이터를 복사해줍니다. 

OnRead 함수는 실질적으로 받은 버퍼의 데이터을 읽었으면 커서를 읽은 위치까지 옮겨주는 함수입니다. 
인자로 int32 타입으로 numOfBytes 를 받는데 WSARecv 에서 받은 데이터의 크기를 알 수 있는데 이 값입니다. 즉 이번 시행에서 읽은 데이터의 크기입니다. 
이 받은 데이터 크기값이 DataSize() 보다 크면 이상한 상황입니다. 버퍼에 사용가능한 범위 이상으로 데이터를 받았다는것이니 예외처리를 해줍니다. 
그 후 받은 데이터 크기만큼을 _readPos에 더해줘 커서를 옮깁니다. 

OnWrite 함수도 OnRead 와 비슷한 형태입니다. 다만 여기서도 int32 numOfBytes 를 받는데 이 크기가 FreeSize() 보다 큰 경우가 예외처리를 해야할 상황입니다.
통과했다면 _writePos에 더해줘 커서를 이동합니다. 


이렇게 만든 RecvBuffer 클래스를 Session 에 적용해봅니다. 

Session 클래스에 RecvBuffer 를 include 해주고 기존 BYTE 배열로 사용하던 _recvBuffer 를 RecvBuffer 타입으로 들고 있게 한 후 
Session 생성자에서 64KB 크기 (0x10000) 를 enum으로 관리해 준 후 이 크기만큼을 _recvBuffer 의 크기로 지정해 초기화 해줍니다. 

그리고 _recvBuffer 를 사용하던 부분은 일단 RegisterRecv 인데 
WSARecv 를 호출하기 위한 인자로 WSABUF 의 내용을 채워주고 있었습니다. 
WSABUF.buf 에 수신받기 시작할 주소를 넣어줘야하는데 이젠 그냥 _recvBuffer 의 맨앞을 넘겨주는게 아니라 WritePos() 를 넘겨줄것입니다. 
WSABUF.len 은 _recvBuffer.FreeSize() 를 주면 됩니다. FreeSize 는 Session 에서 지정한 64KB 보다 훨씬 큰 크기이긴 하지만 이 값의 의미는 사용할 버퍼의 크기를 
넣어주는게 아니라 실제로 받을 수 있는 최대 크기를 넣어주고 사용할 버퍼의 크기는 나중에 Dispatch 에서 numOfBytes 로 받아올것입니다. 

이어서 ProcessRecv 를 봐야합니다. Dispatch 를 통해 성공적으로 버퍼에 데이터를 받아 왔다는 것입니다. 그러면 받아온 크기만큼 _writePos 를 땡겨줘야합니다. 
그리고 컨텐츠 단에서 받아온 데이터를 처리하는 OnRecv 함수에는 받은 데이터의 시작 주소와 쌓인 데이터 크기를 넣어 줘야합니다. 하지만 그래도 받은 데이터를 모두 소모할지는 
아직 모르기 때문에 processLen 이라는 변수로 받아줍니다. 
processLen 의 크기가 0보다 작거나 아니면 DataSize(_writePos와 _readPos 의 차이) 보다 크거나 아니면 OnRead를 ProcessLen 만큼 해서 커서를 땡긴 결과가 false 라면 
에러가 있는 상황이고 다 통과하면 잘 동작한것입니다. 

OnWrite, OnRead 를 모두 했다면 한번 Clean 을 호출해 커서 정리를 시도합니다. 
만약 DataSize() 가 0이라면 가볍게 커서를 앞으로 땡겨주고 그렇지 않아도 남은 용량이 버퍼 하나보다 작다면 앞으로 땡겨줍니다. 


여기 까지 하고 빌드를 하면 에러가 하나 뜰 건데 Listener 쪽입니다. 
이전에 AcceptEx 를 할때 클라이언트와 연결할때 수신받을 버퍼의 시작주소를 넘겨 줬었는데 session->_recvBuffer.WritePos() 를 넘겨주면 됩니다. 