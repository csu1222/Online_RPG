#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>

// Lock 구현 이론 

/*
직접 Lock을 구현해보겠습니다. 
멀티쓰레드 프로그래밍에서 Lock 이 워낙 중요하다보니 직접 구현해봐서 그 이해도를 높여보겠습니다. 

락을 걸렸을때 외부에서 기다리는 것도 세부적으로 상황이 나뉠 수 있습니다. 
크게 3가지 입니다. 

1. 그냥 무작정 기다리기 : 먼저 락을 걸고 동작중인 쓰레드가 있으면 뒤에 도착한 쓰레드는 락을 풀릴때 까지 계속 기다리는 방법입니다.
		스핀락이라고 부르는 락입니다. 
2. 일단 자리로, 나중에 다시 : 도착했는데 만약 락이 걸려 있으면 해당 쓰레드는 휴면 상태가 되어 다른 쓰레드에 코어가 할당되고 나중에 
		일정 시간이 지난후 다시 락이 걸렸는지 체크하러 옵니다. 좀 더 효율적인것 같지만 휴면상태일때 다른 쓰레드가 다시 락을 잡는다고 하면
		또 다시 밀리는 방식입니다. 
3. 나중에 사용가능해 지면 알려줘 : 락이 풀리면 나에게 알려달라고 누군가에 부탁하고 자신은 휴면에 들어가 연락이 올때 깨어나 작업을 진행합니다. 
		락을 기다리는 쓰레드 입장에서는 효율적이지만 알려달라고 부탁받은 누군가의 리소스를 또 사용한다는 문제가 있습니다. 

어떤 방식이 무조건 우월하고 그런건없고 상황에 따라 내가 구현하는 기능에 따라 적절한 방법을 골라 사용하면 됩니다. 

추가로 무작정 기다리는 스핀락 방법의 장점이 한가지 더 있는데 락에서 휴면상태로 가는 다른 방법에 비해 이 휴면하는 동작의 부하가 없습니다.

이 쓰레드의 휴면과 동작을 오가는 것을 
컨텍스트 스위칭 이라고 합니다. 

컨텍스트 스위칭는 커널모드와 유저모드를 가로지르는 것을 말합니다. 
이 컨텍스트 스위칭이 생각보다 부하가 많이 걸립니다. 왜 그러냐면 유저모드에 있던 쓰레드는 자신이 어떤 상태인지 무엇을 하고 있었는지를 
레지스터에 두고 작업을 하다 커널모드로 가게 되면 이 레지스터의 데이터를 RAM 으로 싹 복사하고 코어가 다른 쓰레드에 할당되면 빙의된 쓰레드의 
이전 데이터들을 다시 RAM에서 가져와 레지스터에 올리고 작업을 시작합니다. 

그렇기 때문에 컨텍스트 스위칭이 부하가 많이 걸립니다. 
무조건 컨텍스트를 절대 하면 안된다는건 아니고 피할 수 있으면 피하는게 좀 더 이득이라는 것입니다. 

자주 사용하는 std::cout 함수도 컨텍스트 스위칭이 일어나는 함수입니다. 유저모드에서 작성한 로그를 출력하려면 커널모드로 가서 프롬프트에 출력해주게 됩니다. 

이 컨텍스트 스위칭에 대해 알고 나서 다시 락의 종류를 보면 좀 더 많이 보일 것입니다. 
*/

int main()
{

}
