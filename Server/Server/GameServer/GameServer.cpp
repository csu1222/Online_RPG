#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include <windows.h>
#include <future>

#include "ConcurrentQueue.h"
#include "ConcurrentStack.h"

// Lock Free Stack

/*
멀티쓰레드 환경에서도 Lock 을 기반으로 하지 않는 스택을 만들어보겠습니다. 

락 프리 스택, 락 프리 큐 는 락이 없다고 하니깐 기존 락을 사용하는 스택, 큐 보다 훨씬 빠를것 같아 보입니다. 
하지만 실제 그 성능을 생각만큼 우월하지는 않다고 합니다. 하지만 그 구현 난이도는 훨씬 높은것이 특징입니다. 
락 프리 프로그램은 아주 많은 사람들이 연구하고 있는 분야라고 합니다. 

ConcurrentStack 에서 실습할것입니다. 

일단 락 프리 스택은 스택 자체를 표준 스택이 아니라 직접 만들어야 합니다. 
스택은 노드 기반으로 만들어 집니다. 템플릿으로 타입을 받아 그 타입 변수와 다음 노드를 포인터로 들고 있는 노드입니다. 

그리고 락프리 스택은 그 노드의 포인터를 아토믹 변수로 만들어 헤드 변수로 가지고 있을겁니다. 
헤드는 어떤 역할이냐면 노드들이 서로를 넥스트 노드로 물고 있을텐데 그 중 가장 앞에 있는 노드를 가리키는 포인터입니다.
그러면 이후 Push를 하면 데이터를 받아 새 노드를 만들고 새 노드의 넥스트로 헤드를 가리킵니다. 
그 후 헤드는 기존 가리키던 노드 대신 새 노드를 가리킵니다. 그러면 스택 맨 앞에 새 노드가 추가되는데 

이 과정중에 새 노드의 넥스트로 헤더를 가리키는 것과 헤더가 노드를 가리키는 사이가 쓰레드 세이프 하지 않습니다. 

여러 쓰레드가 이 코드에 거의 동시에 접근하게되면 
두개의 새 노드가 만들어지게 될것이고 그 중 1번 노드의 넥스트를 헤더로 가리킨 후 2번 노드의 넥스트도 헤더를 가리킵니다
이때 헤더를 가리키는 넥스트가 두개가 되는데 다음 코드가 또 연달아서 진행되면 헤더가 1번 노드를 가리켰다가 다시 
2번 노드를 가리키게 됩니다. 그러면 헤더를 다은 노드라고 가리키는 노드는 두개 인데 
헤더 노드가 가리키는 노드는 한개뿐입니다. 그러면 남은 노드는 사실상 유실되는것입니다. 

이것을 방지하기위해 헤더를 Node* 의 아토믹 변수로 만들었고 이전에 배운 CAS 패턴을 사용하는 함수 
compare_exchange_weak 를 사용해 이중체크와 아토믹적 코드 진행을 한번에 합니다. 


여기서 락프리 프로그램에 대해 눈치 챌 수 있는것이 
락프리 프로그램이라고 해도 경합이 없는 방식이 아니라는것입니다. 명시적으로 락을 사용하지 않는다 뿐이지 
아토믹을 사용해 경합이 생긴다는것을 알 수 있습니다. 


다음은 Pop 입니다. 여기서도 TryPop 으로 만들어서 팝을 할때 경합상황일때도 계속 시도하는 팝을 만들어봅니다.
팝의 원리는 스택의 맨앞의 노드를 헤더가 가리키고 있을텐데 이 노드를 따로 올드헤드라고 따로 저장한 후 
헤드는 올드헤드의 다음 노드를 가리키도록 합니다. 그 후 올드노드의 데이터를 인자에 담아 반환하고 
올드헤드를 삭제합니다. 
팝은 시작부터 헤더를 옮기는데 이때도 멀티 쓰레드 환경에서는 위험한 작업이니 CAS 를 사용해 진행합니다. 
그리고 나서 데이터를 반환하고 올드헤드를 삭제해야 메모리 누수가 안일어나는데 
이 올드 헤드를 또 함부로 삭제하지 못하는 것이 만약 1번 쓰레드가 올드헤드의 삭제 직전인데 
2번 쓰레드가 그 와중에 팝에 들어와 삭제 직전인 올드 헤드를 CAS하려고 한다면 2번 쓰레드의 올드헤드는 
1번쓰레드가 삭제한 올드헤드 메모리에 접근해 ->next를 사용하게 되면서 크래시가 납니다. 

그러면 Pop에서 올드헤드를 삭제하는 방법을 알아보겠습니다. 
여러 방법이 있는데 그중 가장 단순한 방법을 알아볼겁니다. 

올드헤드를 메모리 누수가 발생하는데에도 불구하고 삭제를 하지못하는것은 TryPop 함수에 둘 이상의 쓰레드가 동시에 접근할경우
어느 한쪽에서 이미 해제된 올드헤드에 접근 할 수 있어서 입니다. 

쉽게 생각하면 Push 는 여러 쓰레드가 할 수 있도록 하고 TryPop 은 단 하나의 쓰레드만 작업할 수 있게 해둔다면 
괜찮아 보입니다. 
하지만 자료구조를 만들때 이런 상황에서만 사용하게끔 만드는것은 좋지 않으니 여러 상황에서도 쓸 수 있게끔 만들어 줘야 합니다. 
그러면 TryPop 을 여러 쓰레드가 사용하고 있다면 그 올드 헤드를 여러면이서 참조하고 있으면 삭제할 수 없고 
마지막으로 참조하고 있던쓰레드에서 맨 마지막에 삭제를 해주도록 하면됩니다. 

이렇게 보니 쉬워보이는데 마치 shared_ptr 같습니다. 
PopCount 라는 변수를 만들어 이 TryPop에 들어온 쓰레드는 카운트를 증가시키고 나갈때 감소시키도록 만들겁니다. 
이때 삭제가 필요한 헤더들을 모아두고 아무 참조가 없을때 삭제해주겠습니다. 

TryPop 을 의사 코드로 표현해보자면 
1. TryPop에 쓰레드가 들어오면 _popCount를 원자적으로 1 증가 시킵니다.
2. 현재 헤드를 새 노드포인트 변수 올드헤드에 저장합니다. 
3. 올드헤드가 유효하고, 현재 헤드와 올드헤드가 같은지를 체크합니다. 
4. 현재 헤드와 올드헤드가 동일하다면 현재 헤드를 올드헤드의 다음 노드를 저장합니다.
5. 현재 헤드와 올드헤드가 동일하지 않다면 올드 헤드를 현재 헤드로 저장하고 다시 3번 으로 갑니다.
6. 이제 올드 헤드는 스택과 분리되었습니다.
7. 올드헤드가 nullptr 이라면 스택이 비어있는 상태이니 _popCount를 감소시키고 함수를 종료합니다. 
8. 올드헤드가 유효하다면 인자 value에 올드헤드의 데이터를 저장합니다. 
9. 올드헤드를 삭제시도(TryDelete) 합니다.

TryPop 은 이런 순서로 진행이 됩니다. 
이후 삭제 시도하는 함수를 만들어 주면 됩니다. 이 TryDelete 에서는 _popCount의 값에 따라 
삭제 가능한 상황이면 노드를 삭제하고 삭제가 불가능한 상황이면 _pendingList에 넣어줄것입니다. 

TryDelete 를 또 의사 코드로 표현해보겠습니다. 
1. _popCount를 체크해 자신이 TryPop에 남은 마지막 쓰레드인지를 체크합니다.
2. 만약 _popCount가 1이라서 자신이 마지막 쓰레드라면 새 노드 포인터 변수에 _pendinList 노드를 
저장하고 _pendingList는 nullptr로 밉니다(atomic의 exchange 메소드)
3. 2의 코드를 진행하는 동안 혹시 다른쓰레드가 들어왔는지 다시 _popCount를 1 빼면서 체크합니다.
4. 자신 혼자라면 2에서 만든 노드를 DeleteNode 로 삭제합니다.
(DeleteNode는 시작노드부터 next를 타고가면서 스택의 노드들을 모두 삭제합니다.)
5. 3의 결과로 중간에 다른쓰레드가 끼어들었다면 2의 노드를 다시 _pendingList에 가져다 놓습니다.
6. 4에서 DeleteNode 한 노드는 현재 Pop한 올드헤드는 빠져 있으니 올드헤드는 따로 삭제합니다.
7. 만약 2에서 _popCount가 1이 아니었다면 다른 쓰레드가 있다는것입니다. 만약 2의 노드가 nullptr이 아니라면
올드헤드를 _pendingList 의 앞에 추가하고 _popCount를 줄이면서 TryDelete를 종료합니다. 

이렇게 락프리 방식의 스택을 구현해봤습니다.
이 락프리 스택에서 문제가 발생할 수 있는 점은 지근 TryDelete 에서 _popCount가 1일때만 쌓인
_pendingList 의 노드들을 삭제하고 있는데 Push 하는 데이터가 너무 많고 
이 데이터를 처리하기위해서 TryPop 하는 쓰레드들의 수도 너무 많다면 
_popCount가 1이 잘 되지 않아서 계속 _pendingList만 늘어나고 실제 데이터 삭제는 안 이뤄질 수도 있습니다. 
*/

// 기존 큐, 스택 
queue<int32> q;
stack<int32> s;

// 만들어본 Lock 기반 큐, 스택
LockQueue<int32> lockQueue;
LockFreeStack<int32> lockFreeStack;

void PushNomal()
{
	while (true)
	{
		int32 value = rand() % 100;
		q.push(value);

		this_thread::sleep_for(10ms);
	}
}

void PopNormal()
{
	while (true)
	{
		if (q.empty())
			continue;

		int32 data = q.front();

		q.pop();

		cout << data << endl;
	}
}

// Lock 기반 테스트 함수
void PushLock()
{
	while (true)
	{
		int32 value = rand() % 100;
		lockFreeStack.Push(value);

		this_thread::sleep_for(10ms);
	}
}

void PopLock()
{
	while (true)
	{
		int32 data = 0;

		if (lockFreeStack.TryPop(OUT data))
			cout << data << endl;
	}
}

int main()
{
	// 기존 큐, 스택
	{
		thread t1(PushLock);
		thread t2(PopLock);

		t1.join();
		t2.join();
	}
}
