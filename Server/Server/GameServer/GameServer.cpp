#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include <windows.h>
#include <future>

// CPU 파이프라인

/*
이번에는 이 CPU 파이프라인의 내용을 알아보기 전에 먼저 실습을 해봤습니다. 
두 쓰레드가 공유 데이터를 서로 수정하면서 일반적인 싱글쓰레드 환경에서는 있을 수 없는 조건을 걸었는데
그 조건이 통과되는 횟수를 카운팅하는 실습입니다. 

이런 문제가 일어나는 이유가 두가지 있습니다. 

1. 가시성 
	가시성은 캐시와 관계가 있는데 CPU가 어떤 값을 쓰거나 읽을때 그 데이터가 있는 메모리 주소까지 가서 읽거나 쓸 수도 있지만 
	캐싱을 활용하면서 꼭 해당 주소로 매번 가지 않고 사용할만한 데이터를 캐싱해 가져오면 이 캐시 메모리주소로 접근해 처리를 하게 됩니다. 
	그렇다 보니깐 두 쓰레드가 공유 메모리의 값을 수정할때 그 값이 위치한 주소가 실제 데이터 주소라는 보장이 없습니다. 
	캐시에 위치한 값을 가지고 동작하고 있을 수도 있습니다. 물론 각 쓰레드는 값을 수정한 다음 원래의 주소로 값을 복사하겠지만 
	이 동작 사이에 멀티쓰레드는 끼어들어서 동작하기도 하는겁니다. 
	이것을 가시성이라고 합니다. 말 그대로 보이느냐 안보이느냐 라는 것인데 다른 쓰레드에서 하는 동작이 보이는지 안보이는지의 문제입니다. 

2. 코드 재배치
	코드 재배치 문제는 사실 알아야 할때 우리가 직접 작성하는 코드가 컴파일러가 변환할때 그 코드 그대로 변환하지 않을 수 있습니다. 
	컴파일러의 로직하에 더 성능이 좋다고 판단되는 순서로 코드를 재배치 할 때가 있습니다. 
	컴파일러는 멀티쓰레드 환경은 고려하지 않고 기본적인 싱글 쓰레드 환경에서의 성능만을 고려합니다. 
	거기다가 혹시 컴파일러가 코드 재배치를 하지 않더라도 CPU에서도 마음대로 코드를 재배치 하는 경우도 있습니다. 

왜 이런 문제가 발생하는지를 알아보겠습니다. 

CPU 파이프라인을 빨래에 비유 할 수 있습니다. 
빨래를 할때 빨래감들이 담겨 있는 빨래 바구니가 있을 것이고 또 빨래를 하는 세탁기들이 있을겁니다. 
그리고 나서는 빨래를 말리고 다림질을 하게 될것입니다. 

이렇게 빨래 바구니, 세탁기, 건조, 다림질 4단계를 거쳐야 빨래가 완성이 되는데 

빨래를 할때 한 바구니의 빨래가 모든 단계를 거쳐 완성이 될때 까지 다른 빨래들은 진행하지 않는 경우가 
기본적인 싱글쓰레드일겁니다. 
이 방식은 비효율적일 겁니다. 모든 단계가 쉬는시간 없이 연달아 진행하는게 더욱 시간을 아끼는 방식이라고 알 수 있습니다. 

문제는 빨래자체의 일의 약이 모두 동등하지는 않을겁니다. 
어떤 빨래는 양이 많아서 오래 빨고 오래 건조해야하고 어떤 빨래는 다림질이 어려워 다림질이 오래걸릴겁니다. 

이런경우 빨래 바구니가 들어온 순서대로가 아니라 어떤 특정 순서로 바꿔 처리하면 더욱 빨리 처리가 된다면 순서를 바꿔 처리할 수 있을겁니다. 


이것과 똑같은 문제가 CPU에서도 발생하는것입니다. 
CPU 에서도 일감을 처리할때 
fetch , decode, execute, write-back 네단계를 거치게 되는데 이것을 CPU 파이프라인이라고 하는겁니다.
이런 상황에서 빨래의 예시처럼 작성한 코드의 순서대로 처리하기보다 더욱 빠른 속도가 날것 같으면 이 코드의 순서를 바꿔 줄 수 있습니다.

하지만 이 동작의 장점은 싱글쓰레드에서는 대부분 옳겠지만 
멀티쓰레드 환경에서는 문제가 됩니다. 

코드 재배치가 일어나는 이유를 알았지습니다. 

이 것을 방지하는 방법또한 당연히 있습니다. 
현대에서는 멀티쓰레드가 보편화 되었고 그에 맞추어 C++11 부터는 표준으로 이것을 해결하는 방법들이 포함되었다고 합니다. 
*/

int32 x = 0;
int32 y = 0;
int32 r1 = 0;
int32 r2 = 0;

volatile bool ready;

void Thread_1()
{
	while (!ready)
		;

	y = 1; // Store y
	r1 = x; // Load x
}

void Thread_2()
{
	while (!ready)
		;

	x = 1; // Store x
	r2 = y; // Load y
}

int main()
{
	int32 count = 0;

	while (true)
	{
		ready = false;
		count++;

		x = y = r1 = r2 = 0;

		thread t1(Thread_1);
		thread t2(Thread_2);

		ready = true;

		t1.join();
		t2.join();

		if (r1 == 0 && r2 == 0)
			break;
	}

	cout << count << " 번만에 빠져나옴" << endl;
}
