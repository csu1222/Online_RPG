#include "pch.h"
#include <iostream>
#include "CorePch.h"
#include <thread>
#include <atomic>
#include <mutex>
#include <windows.h>
#include <future>

// 캐시 

/*
이 다음 이어서 알아볼 메모리전에 기반으로 캐시에 대해 알아보겠습니다. 

캐시는 컴퓨터의 하드웨어중에 HDD 혹은 SSD, RAM, CPU 에 대해 알아야 합니다. 
SSD 혹은 HDD 는 아주 큰 용량의 메모리인데 물리적으로도 CPU와 멀고 또 워낙 크기가 크다보니 데이터를 찾는데 컴퓨터 부품중 비교적 느린 속도를 가집니다.
또 비 휘발성 메모리로 컴퓨터의 전원이 나가도 계속 그 정보를 가지고 있습니다. 
RAM은 휘발성 메모리로 여기 들은 정보들은 컴퓨터 전원이 꺼지면 다 날아갑니다. HDD, SSD 의 데이터를 프로그램을 실행할때 필요한 데이터를 RAM 에 올려두고 사용합니다.
CPU는 실제 구조상 실질적으로 연산을 담당하는 ALU(산술논리연산장치), CPU 안에서 어떻게 동작해야할지를 조율하는 제어장치, 그리고 CPU 안에 있는 메모리인 레지스터입니다. 
레지스터가 물리적 거리도 가장 가까운 메모리고 ALU는 이 레지스터에 올라온 데이터를 가지고 연산합니다. 

여기에 추가로 레지스터 외에도 캐시영역이 있습니다. 레지스터와 RAM 사이에 직접 접근하는것도 속도가 느릴 수 있어서 캐시에 올려두고 사용합니다. 

이런 캐시는 두가지 철학으로 만들어 집니다. 
1. TEMPORAL LOCALITY
	시간적으로 방금 사용한 데이터를 또 다시 사용할 확률이 높다.
2. SPATIAL LOCALITY
	공간적으로 방금 사용한 데이터 근처의 데이터를 사용할 확률이 높다. 
이 두가지 철학을 고려해 캐시를 설계한다고 합니다. 

테스트를 해보는데 10000 * 10000 의 크기를 가진 버퍼를 순회하는데 걸리는 시간을 측정해보는데 
1차 인덱스 먼저 그 다음 2차 인덱스 먼저 순회를 하는것과 2차 먼저 1차 먼저 순회를 하는 시간을 테스트 해봤습니다. 

아무런 컴퓨터 공학적 지식없이 생각해보면 어느 순서로 순회를 하던지 총 인덱스 수는 같기 때문에 의미가 없을것 같지만
전자의 경우가 후자의 경우보다 3배정도 빠른걸 알 수 있습니다. 

이게 캐싱이 제대로 동작하는 증거입니다. 

왜 이런 현상이 일어나냐면 
2차 배열이라는것 자체가 1차배열을 여러개 늘여 놓는겁니다.    
	
	[][][][][][][][]   [][][][][][][][]  [][][][][][][] ... 
이런식인데 전자의 방식인 1차인덱스먼저 2차인덱스를 나중에 순회하는것은 
위의 메모리에서 맨 앞에서부터 차례대로 스캔을 하는것입니다. 

위에서 캐싱의 설계에서 봤듯이 사용할 데이터 를 캐시에 가져올때 그 데이터만 가져오는게 아니라 그 인접한 데이터도 가져옵니다. 
그렇기 때문에 인접한 메모리를 스캔할때 미리 가져왔기 때문에 더 빨리 동작할 수 있습니다. 이것을 캐시 힛 이라고 부릅니다. 

반면 후자의 경우 2차 인덱스 먼저 1차 인덱스를 순회하는 방법의 경우는 
위의 배열 뭉치에서 첫번째를 스캔하고 다음 뭉치의 첫번째 인덱스를 스캔하는 식으로 동작하는겁니다. 
그렇다 보니 미리 가져온 캐시데이터가 확실한 효과를 보지 못하는것입니다. 

*/

// 2차 배열을 만들어 줍니다. 
int32 buffer[10000][10000];

int main()
{
	// 값을 0으로 밉니다. 
	memset(buffer, 0, sizeof(buffer));

	// 버퍼를 순회하는데 i j 순으로 접근해 걸리는 시간 
	{
		uint64 startTick = GetTickCount64();

		int64 sum = 0;
		
		for (int32 i = 0; i < 10000; i++)
			for (int32 j = 0; j < 10000; j++)
				sum += buffer[i][j];

		uint64 endTick = GetTickCount64();

		cout << "Elapsed Tick : " << (endTick - startTick) << endl;
	}

	// j i 순으로 접근해 걸리는 시간 
	{
		uint64 startTick = GetTickCount64();

		int64 sum = 0;

		for (int32 i = 0; i < 10000; i++)
			for (int32 j = 0; j < 10000; j++)
				sum += buffer[j][i];

		uint64 endTick = GetTickCount64();

		cout << "Elapsed Tick : " << (endTick - startTick) << endl;
	}
}
