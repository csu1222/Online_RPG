Lyra 는 에픽게임즈에서 공식으로 배포하는 게임 프로젝트로 실제 현업수준의 거대한 프로젝트입니다. 
이 프로젝트는 언리얼 업데이트마다 그에 맞춰 업데이트되는 사실상 에픽게임즈에서 게임 제작 가이드라인의 역할을 하고 있고 
실제로 이 Lyra를 참조해 만든 게임들이 많다고 합니다. 

하지만 그만큼 내용이 방대하기 때문에 혼자 Lyra를 분석하기는 어렵습니다. 그래서 필요한 부분을 살펴보고 가져올 수 있는 방법이 있다면 가져와 사용하겠습니다. 

라이라 프로젝트는 모듈화가 잘 되어 있는 프로젝트입니다. 
이런 모듈화를 배워서 우리 프로젝트로 가져오는게 목표가 되겠습니다. 

#
에러 - 언리얼 5.5, 5.6 버전에서는 실행중 중단점이 호출되거나 빌드자체가 안되는데 5.4버전에서는 정상적으로 동작합니다. 
#

# 1 모듈 
{
	언리얼 프로젝트에서 모듈이 뭔지를 정의하자면 비쥬얼 스튜디오로 연 언리얼 프로젝트의 소스디렉토리 아래의 폴더 하나하나를 모듈이라고 할 수 있습니다. 적어도 라이라 프로젝트에서는
	그렇게 사용하고 있습니다. 그리고 프로젝트 아래의 플러그인 디렉토리와 그리고 프로젝트 파일까지 해서 
	모듈, 플러그인, 프로젝트 3가지가 언리얼 3대 요소라고 합니다. 

	이 3가지 요소의 개념을 정리하자면 
	모듈의 구성요소는 cpp 파일과 h 파일입니다. 매번 클래스를 추가하면서 생기는 파일들이었습니다. 프로젝트의 uproject 파일을 열어보면 모듈을 지웠다 작성하는걸로 프로젝트에 포함할지를
	정할 수 있습니다. 
	플러그인은 무엇이냐면 모듈들을 모은 개념입니다. 그러면 또 모듈은 cpp와 h로 이루어 져있을 겁니다. 플러그인도 마찬가지로 uproject 파일에서 Enable 값을 ture, false 를 주는걸로 
	포함 여부를 정할 수 있습니다. 

	모듈과 플러그인이 비슷해 보이는데 그 차이가 뭔지 알아보자면 에픽게임즈에서 실험적인 기능들을 플러그인으로 넣고 테스트를 합니다. 
	테스트를 하다가 이 플러그인이 안정성이 높고 유저들이 잘 사용한다 싶으면 그때 모듈로 옮기는 것입니다. 

	그럼 프로젝트가 뭐냐면 모듈과 플러그인을 모두 들고 있을 수 있는 큰 개념이고 거기에 한가지 더 컨텐츠 폴더도 들고 있을 수 있어서 에셋들도 관리합니다. 

	다시 쉽게 정리하자면 모듈은 이 프로젝트에서 안정적으로 사용할 수 있는 기능, 플러그인은 모듈들을 모아둔거지만 약간 외부에서 가져온 기능들로 안정성과 사용성이 모듈보다는 덜 
	증명된 기능 묶음, 그리고 프로젝트는 모듈, 플러그인, 에셋들을 모두 포함한 개념 이라고 할 수 있습니다. 

	새로만든 프로젝트를 보면 기본적으로 모듈이 하나 생성되어 있습니다. 
	프로젝트명.cpp, 프로젝트명.h 가 그것들인데 여기의 상단에는 IMPLEMENT_PRIMARY_GAME_MODULE 이라는 define이 있습니다. 이 define 함수는 게임모듈을 정의 하고 등록하는데 
	이때 인자로 FDefaultGameModuleImpl 을 주면 디폴트 모듈로 LC_5_4 로 등록합니다. 

	클래스를 만들면서 FDefaultGameModuleImpl 를 상속받게 되면 기본 모듈을 상속받은 나만의 커스텀 모듈을 만들 수 있습니다. 
	이때 중요한것은 지금 만든 모듈을 엔진에 사용하라고 명시를 해줘야합니다. 

	IMPLEMENT_PRIMARY_GAME_MODULE의 인자로 FDefaultGameModuleImpl 대신에 지금 새로 만든 커스텀 모듈을 넣어주는 것으로 새 커스텀 모듈을 사용하도록 명령을 한것입니다. 
	이 모듈을 만들고 사용하도록 하는 기술을 라이라에서 사용하고는 있지 않지만 일단 모듈에 대해 알기 위해서 실습을 해봅니다. 
	새 모듈의 StartModule 멤버 함수를 만들어 중단점을 걸고 실행해보면 언리얼 에디터가 완전 실행되기전에 중단점에 걸립니다. 

	주의해야할 점이 있습니다. 
	라이라 프로젝트에서 지금 배운 IMPLEMENT_PRIMARY_GAME_MODULE 부분을 확인할건데 라이라 프로젝트는 소스 폴더에서도 라이라 게임과 라이라 에디터모듈 두개로 나뉘어 있습니다. 
	그 중에 라이라 게임 모듈 cpp 파일에서 IMPLEMENT_PRIMARY_GAME_MODULE 함수를 사용하고 라이라 에디터 모듈에서는 IMPLEMENT_MODULE 로 설정하고 있습니다. 

	IMPLEMENT_PRIMARY_GAME_MODULE는 이름에서 알 수 있듯이 프로젝트에서 딱 하나만 설정할 수 있습니다. 두개의 모듈을 설정하면 실행이 되지 않습니다.
	거기에 에러가 이상하게 뜨기 때문에 문제를 알기도 힘듭니다. 
	그렇기 때문에 라이라 프로젝트처럼 라이라 게임에서 IMPLEMENT_PRIMARY_GAME_MODULE을 사용했다면 라이라 에디터에서 IMPLEMENT_MODULE를 사용해도록 해줘야합니다. 

	가장 중요한 기초 모듈에 IMPLEMENT_PRIMARY_GAME_MODULE를 하고 그 외의 모듈에서는 IMPLEMENT_MODULE를 호출해 줘야합니다. 

	LC 프로젝트에서 새로 만든 모듈에 로그를 하나 찍어서 테스트를 해봅니다. 여기까지 실습으로 모듈이 뭔지에 대한 개념 그리고 커스텀 모듈이 잘 설정되었는지를 확인할 수 있습니다. 
}


# 2 로그 
{
		앞으로 디버깅을 하면서 로그를 많이 찍어볼건데 언리얼에서 로그를 커스텀 할 수 있게 지원을 해줘서 디버깅에 필요한 로그들을 가독성 있게 볼 수 있도록 할것입니다. 
	LC 프로젝트를 실행하고 C++ 클래스를 생성하는데 None을 선택해서 아무것도 상속받지 않고 생성을 해주는데 기본생성되는 클래스는 지워주겠습니다. 

	헤더 파일에 두가지 헤더를 추가해주는데 Containers/UnrealSting.h 와 Logging/LogMacros.h 입니다. 
	그리고 나서 
	DECLARE_LOG_CATEGORY_EXTERN(LogLC, Log, All);
	이런 매크로를 사용해주게 되면 LogLC 라는 새 로그 카테고리를 만들게 되는겁니다. 그런데 헤드에만 선언하면 안되고 
	cpp 파일에서 다시 
	DEFINE_LOG_CATEGORY(LogLC);
	이렇게 정의 해줘야합니다.

	새로 만든 로그 카테고리를 어떻게 사용하냐면 이전에 로그를 찍을때 LogTemp 를 사용했던 부분을 LogLC 로 바꿔주면 이 카테고리의 로그로 출력이 됩니다. 
	앞으로 로그를 찍을때 카테고리로 나눠서 사용하게 되면 출력 로그에서 검색해 확인 하기 편해집니다. 
}


# 3 에셋 매니저
{
	에셋이란 모델링이나 사운드파일 같이 프로그래밍 외의 직군쪽에서 만든 리소스들을 말합니다. 
	이런 에셋을 매니징하는 에셋 매니저를 프로젝트에 추가할겁니다. 왜 에셋매니저를 사용하냐면 이것을 사용하기 전에는 직접 에셋을 임포트하고 수정하고 싶은 옵션을 가져와서 
	수정을 하게되는데 이동작들이 하드코딩적입니다. 에셋의 바꾸고 싶은 옵션의 경로가 바꾼다고 하면 이 에셋을 수정한 모든곳을 수정해야합니다.

	그래서 에셋매니저를 사용하게 되는데 에셋매니저를 따라 들어가 설명을 보면 싱글톤으로 PrimaryAsset 을 로딩이나 언로딩을 한다고 합니다. 프라이머리 에셋이 뭔지는 뭐르겠지만
	일단 넘어갑니다. 

	싱글톤은 프로젝트내에서 유일성을 보장해야하는 패턴입니다.
	에셋매니저에서 Get 이라는 함수를 사용할텐데 여기서 GEngine 에서 에셋 매니저를 가져와 ULcAssetManager 라는 제가 사용할 에셋매니저 타입으로 캐스팅해서 리턴을 할겁니다. 
	GEngine 이라는 글로벌로 사용하는 엔진 객체를 사용하면 이 에셋 매니저를 Get으로 가져올때마다 새로 생성하는게 아닌겁니다. 

	ShouldLogAssetLoads 라는 static 멤버 함수를 하나 추가할겁니다. 이 함수는 새로운 기법하나를 소개하는 용도인데 
	커맨드 프롬프트에서 LogAssetLoads 라는 문자를 포함하고 있는지를 불리언으로 반환하는 함수입니다. 

	bool ULcAssetManager::ShouldLogAssetLoads()
	{
		const TCHAR* CommandLineContent = FCommandLine::Get();
		static bool bLogAssetLoads = FParse::Param(CommandLineContent, TEXT("LogAssetLoads"));
		return bLogAssetLoads;
	}

	커맨드 라인에서 LogAssetLoads 라는 문자열이 있는지를 찾는다고 했는데 언리얼엔진을 실행하는데 왠 커맨드라인 인가 싶을수 있습니다. 
	그런데 프로젝트의 속성 - 디버그 - 명령 인수 를 보면 프로젝트의 uproject 을 실행하면서 뒤에 -skipcompile 이라는 인자를 같이 주고 있습니다. 여기에 추가로 
	-LogAssetLoads를 추가하게되면 위의 ShouldLogAssetLoads 함수가 true 로 반환되는겁니다. 
	이 함수를 통해 FCommandLine 이라는 함수에서 인자를 가져와 활용할 수 있다를 보여주고 언리얼에서도 커맨드라인 인자를 넣을 수 있다는것도 알 수 있었습니다. 

	SynchronousLoadAsset 이라는 멤버 함수를 하나 더 추가하겠습니다. 
	함수 명칭에서 알 수 있듯이 동기화 적으로 에셋을 로드한다는 뜻입니다. 
	다시 동기와 비동기에 대해 집고 넘어가자면 동기식 함수는 A,B라는 함수가 있고 둘 다 호출을 해야할때 A함수의 모든 로직을 실행한 후 B의 로직을 실행하기 시작하는 방식이고
	비동기는 A함수를 실행하는 중에도 B함수를 쓰레드를 할당하거나 하는 방법들로 같이 실행해 A의 로직이 끝나는것과 상관없이 B를 실행하는 것입니다. 

	보통 온라인 게임 로직에서는 비동기 방식을 선호하게 되는데 당연히 동시다발적으로 여러 동작이 일어날텐데 동기방식으로 처리하면 게임 경험이 많이 불쾌해질것입니다. 
	하지만 무조건 비동기 방식을 채택하는건 아닙니다. 

	동기 방식의 장점은 일단 비동기 방식보다 속도가 빠르고 그리고 로직 진행 순서도를 확인하기 쉽습니다. 
	그래서 동기 방식을 어디서 많이 쓰냐면 게임을 시작하거나 맵이 전환되거나하는 로딩 시간때 주로 사용합니다 어짜피 이 시간에는 유저가 조작하지 않기 때문에 
	속도가 중요하고 로직순서에 따른 문제를 최소화할 수 있는 동기 로딩을 사용하는것입니다. 그래서 이 함수 SynchronousLoadAsset 를 만든 이유가 
	인게임 중에 동기 로딩이 많아지면 프레임 드랍이 일어날 건데 이런 문제가 동기로딩에서 문제가 생기는지 찾기위해 만든겁니다.  

	UObject* ULcAssetManager::SynchronousLoadAsset(const FSoftObjectPath& AssetPath)
	{
		// 해당 함수를 따로 만든 이유는 'synchronous load asset이 불필요하게 하는 것이 없는지 확인하기 위함'
		if (AssetPath.IsValid())
		{
			// FScopeLogTime을 확인해보자:
			TUniquePtr<FScopeLogTime> LogTimePtr;
			if (ShouldLogAssetLoads())
			{
				// 단순히 로깅하면서, 초단위로 로깅 진행
				LogTimePtr = MakeUnique<FScopeLogTime>(*FString::Printf(TEXT("synchronous loaded assets [%s]"), *AssetPath.ToString()), nullptr, FScopeLogTime::ScopeLog_Seconds);
			}

			// 여기서 두가지 분기:
			// 1. AssetManager가 있으면, AssetManager의 StreamableManager를 통해 정적 로딩
			// 2. 아니면, FSoftObjectPath를 통해 바로 정적 로딩
			if (UAssetManager::IsValid())
			{
				return UAssetManager::GetStreamableManager().LoadSynchronous(AssetPath);
			}

			// if asset manager is not ready, use LoadObject()
			// - 슥 보면, StaticLoadObject가 보인다: 
			// - 참고로, 항상 StaticLoadObject하기 전에 StaticFindObject를 통해 확인하고 실패하면 진짜 로딩함
			return AssetPath.TryLoad();
		}

		return nullptr;
	}

	코드를 보면 FScopeLogTime 이라는 구조체를 UniquePtr로 만들어 LotTimePtr 이라고 들고 있습니다. 이 FScopeLogTime 구조체의 설명을 보면 로그시간을 초당으로 누적 전달하는 구조체입니다.
	위에서 만들어 놓은 ShouldLogAssetLoads 함수를 통해 커맨드라인에 LogAssetLoads 가 있다면 참을 반환해 조건문으로 들어오고 
	FScopeLogTime 를 위의 인자처럼 ScopeLog_Seconds 를 주게되면 초단위로 이 함수가 얼마나 걸렸는지 초단위로 알 수 있습니다. 그래서 동기성 함수를 실행하면서 얼마나 걸린지를 체크 할 수 있습니다. 
	그리고 AssetManager 가 유효하다면 StreamManager 라는걸 가져와서 동기화 로딩을 진행합니다. StreamableManager가 뭐냐면 동기로딩 비동기로딩을 관리하는 클래스입니다. 
	만약 AssetManager가 아직 생성이 안되서 없다면 인자로 받은 에셋 자체에 대해 TryLoad 를 진행합니다. 
	TryLoad도 내부적으로 로딩을 하는건 똑같습니다. 하지만 TryLoad를 따라 들어가 설명을 보면 굉장히 느리다고 합니다. 
	LoadSynchronous 와 TryLoad 둘 모두 로딩을 끝낸 데이터는 캐싱을해서 메모리에 올려두기 때문에 다시 로딩을 시도한다고 해도 캐싱해뒀던 데이터를 가져와 사용합니다.

	그래서 SynchronousLoadAsset 이란 함수는 거의 LoadSynchronous 함수를 그대로 사용하는데 동기로딩을 하는 시간을 한번 재보는 래핑을 한겁니다. 

	지금 이 함수가 정확히 뭔지 다시 비유하자면 게임에서 나중에 여러가지 에셋들 예를 들어 여러 무기들 혹은 캐릭터의 아바타등이 있을겁니다. 그런데 게임이 오래되면 각 종류마다 1000가지의 종류가 또 나눠질 수도 있습니다. 
	그런데 이것들을 항상 모든 클라이언트에서 로딩을 해놔서 메모리에 올려 놓을 수 없습니다. 이런걸 필요한 것들만 로딩하는게 지금 SynchronousLoadAsset 함수 내의 LoadSynchronous 와 TryLoad 입니다. 

	여기서 추가로 게임 로직을 쭉 진행중에 어떤 함수 A의 어느 부분에서 확 느려지는걸 발견을 했다고 하겠습니다. 
	예를들어서 1000초가 걸린다고했을때 위의 LogTimePtr 부분 코드 때문에 이 에셋을 로딩할때 1000초가 걸린다는걸 쉽게 체크할 수 있게 되는겁니다. 
	그래서 이 에셋로드를 동기화 로딩을 하면 안되겠다고 판단이 가능해 집니다. 

	SynchronousLoadAsset 함수에서 한가지 더 집고 넘어갈 부분이 파라매터인 FSoftObjectPath에 대해서인데 
	에셋들이 여러 종류가 있을 수 있습니다. 사운드, 메시, 블루프린트 같은 에셋들이 있다고 할때 위에서 말했듯이 모든 에셋들을 다 메모리에 들고 있을 수는 없습니다. 
	그래서 필요한 에셋을 로드를 해야하는데 그 필요한 에셋을 가리키는게 이 FSoftObjectPath 입니다. 에셋들이 프로젝트 디렉터리 안에서도 해당 경로가 있을겁니다. 

	언리얼 엔진에서 이 경로를 확인 할 수 있는데 언리얼 엔진을 실행시켜서 테스트용 아무 에셋을 하나 만들어 컨트롤 V 를 한 후 메모장에 붙여넣기를 해보면 
	이 에셋이 위치한 경로가 뜹니다. 이 경로를 들고 있는게 FSoftObjectPath의 역할입니다. 
	SynchronousLoadAsset 에 인자로 몇백메가바이트 혹은 그이상 갈 수도 있는 에셋자체를 주는게 아니라 그 경로를 주는겁니다. 마치 객체와 포인터를 보는것 같습니다. 

	다음은 템플릿을 활용한 함수들을 추가합니다. 

	template<typename AssetType>
	inline AssetType* ULcAssetManager::GetAsset(const TSoftObjectPtr<AssetType>& AssetPointer, bool bKeepInMemory)
	{
		AssetType* LoadedAsset = nullptr;
		const FSoftObjectPath& AssetPath = AssetPointer.ToSoftObjectPath();

		if (AssetPath.IsValid())
		{
			// 로딩이 되어있다? -> 바로 가져옴
			// 로딩이 안되어 있다 -> Null
			LoadedAsset = AssetPointer.Get();
			if (!LoadedAsset)
			{
				LoadedAsset = Cast<AssetType>(SynchronousLoadAsset(AssetPath));
				ensureAlwaysMsgf(LoadedAsset, TEXT("Failed to load asset [%s]"), *AssetPointer.ToString());
			}

			if (LoadedAsset && bKeepsInMemory)
			{
				// 여기서 AddLoadAsset은 메모리에 상주하기 위한 장치라고 생각하면 됨:
				// - 한번 등록되면 직접 내리지 않는한 Unload가 되지 않음 (== 캐싱)
				Get().AddLoadedAsset(Cast<UObject>(LoadedAsset));
			}
		}

		return LoadedAsset;
	}

	template<typename AssetType>
	inline TSubclassOf<AssetType> ULcAssetManager::GetSubclass(const TSoftClassPtr<AssetType>& AssetPointer, bool bKeepInMemory)
	{
		TSubclassOf<AssetType> LoadedSubclass;

		const FSoftObjectPath& AssetPath = AssetPointer.ToSoftObjectPath();
		if (AssetPath.IsValid())
		{
			LoadedSubclass = AssetPointer.Get();
			if (!LoadedSubclass)
			{
				LoadedSubclass = Cast<UClass>(SynchronousLoadAsset(AssetPath));
				ensureAlwaysMsgf(LoadedSubclass, TEXT("Failed to load asset class [%s]"), *AssetPointer.ToString());
			}

			if (LoadedSubclass && bKeepInMemory)
			{
				Get().AddLoadedAsset(Cast<UObject>(LoadedSubclass));
			}
		}

		return LoadedSubclass;
	}

	추가한 두가지 함수는 거의 동일한데 반환하는 타입이 AssetType* 인것과 TSubclassOf<AssetType> 인것 밖에 차이가 없습니다. 
	둘 모두 AssetPointer가 가리키는 에셋의 주소를 보고 유효한지 체크 유효하다면 SynchronousLoadAsset을 해서 로드 해오고 로드가 실패했다면 로그를 찍습니다. 
	또다른 매개변수인 이 에셋을 캐싱해둘지 불리언으로 받아 그 값에 따라 AddLoadedAsset 함수를 통해 계속 메모리에 올려둘지를 정합니다. 

	별개의 이야기로 여기 등장하는 용어들과 비슷한 용어를 한번 정리 해보겠습니다. 

	Asset : 블루프린트, 사운드, 메시 등
	Tsubclassof : 특정 클래스의 서브클래스의 타입정보 
	CDO : 클래스의 기본 인스턴스
	staticclass : 리플렉션을 가지고 있는 메타데이터 

	간단하게 이렇게 개념을 정리 할 수 있습니다. 
	그런데 여기서 staticclass 를 설명하는 말중 리플렉션이 무엇인지 좀 더 알아보겠습니다. 
	일단 C++ 자체에는 리플렉션이라는 기능이 없고 그래서 C# 을 통해 설명을 해보겠습니다. 

	리플렉션 이라는 용어의 이름을 보면 반사라는 뜻이 있는데 리플렉션은 런타임 단계에서 클래스에 대한 정보를 알 수 있게 해주는 것입니다. 
	이게 무슨 말이냐면 

	class Test
	{
		public int Num = 0;
		public string Name = "ABC";

		public void Print()
		{
			Console.WriteLine($"{Num}, {Name}");
		}
	}

	이런 클래스가 있고 

	static void Main(string[] args)
	{
		foreach (var Filed in typeof(Test).GetFields())
		{
			Console.WriteLine(Field.Name);
		}
	}

	이렇게 Test 클래스의 타입을 가지고 GetFields 라는 함수로 무언가 데이터를 가져와 출력해보려고 합니다. 

	이 프로그램을 실행해보면 Num과 Name이 한줄씩 출력됩니다. Test 객체를 만들어서 멤버변수를 가져와 본것이 아닌데 
	Test클래스가 가지고 있는 멤버 변수의 식별자를 가져와 버립니다. 
	GetFeilds 라는 함수뿐만아니라 

	foreach (var Method in typeof(Test).GetMethods())
	{
		Console.WriteLine(Method.Name);
	}

	Method를 가져오는 함수를 사용해 실행해보면 Print, GetType, ToString, Equals, GetHashCode 라는 문자열들이 출력됩니다. 

	리플렉션은 이런식으로 런타임 단계에서 클래스의 정보들을 알 수 있는 것을 말하는데 그 활용은 이렇게도 가능합니다. 

	static void Main(string[] args)
	{
		// 빈 Test 객체 생성
		Test a = new();

		// a 의 num값을 출력해보기 
		Console.WriteLine(a.Num);

		foreach (var Filed in typeof(Test).GetFileds())
		{
			// 리플렉션으로 Test에 Num이라는 이름의 변수가 있는지를 체크하고 있다면 인자로 넘겨준 객체의 Num 값을 수정
			if (Filed.Name = "Num")
				Filed.SetValue(a, 100);
		}

		// 수정되었는지 출력
		Console.WriteLine(a.Num);
	}

	C++ 자체 기능으로는 이런 리플렉션 기능이 없습니다. 
	하지만 언리얼같은 엔진에서는 리플렉션 기능이 필요합니다. 언리얼 엔진을 실행시켜서 에셋들의 Details를 살펴보면 이 에셋에서 UPROPERTY매크로를 붙힌 변수들을 
	엔진에서 UI적으로 수정할 수 있습니다. 이 기능도 리플렉션으로 데이터를 가져와 구현하는 것입니다. 

	언리얼엔진에서는 언리얼 빌드 툴, 언리얼 헤더 툴 등으로 C++ 에서도 리플렉션이 가능하도록 만들어 줬습니다. 그 흔적을 찾아보면 
	프로젝트의 Build 파일, Target 파일들이 C#으로 만들어져 있습니다. 

	코드로는 어떤 부분이냐면 UPROPERTY매크로를 붙힌 코드는 리플렉션이 필요하다고 기억을 해두는데 언리얼로 만든 헤더 파일에 기본적으로 추가 되어있는 .generated.h 파일과 
	클래스의 맨위에 자동으로 입력되어있는 GENERATED_BODY() 입니다.

	그런데 이런 리플렉션을 하는 대상인 이 클래스의 변수들의 이름이나 함수들의 이름을 C++의 기본 클래스인 class 가 가지고 있는게 아니라 위에서 알아본 staticclass 가 가지고 있고
	언리얼에서는 staticclass를 UClass 라는 이름으로 만들어 놨습니다. 

	UCLASS 가 붙어 만들어진 언리얼 클래스들은 멤버 함수로 StaticClass(); 라는 함수가 있는데 반환 타입이 UClass 입니다. StaticClass 함수를 따라 들어가보면 Field 라는 타입을들 
	반환한다던가 하는 익숙한 모습이 보입니다. FieldClass 라는것도 따라 들어가보면 이름과 고유 넘버 등 메타 데이터들을 가지고 있습니다. 

	그렇기 때문에 언리얼의 빌드가 오래걸릴 수 밖에 없습니다. 클래스마다 이런 정보들을 하나하나 만들고 빌드를 해야하기 때문입니다. 
	여기까지 staticclass, 리플렉션에 대한 설명이고 

	두번째로 Tsubclassof 가 무엇인지를 알아보겠습니다. 
	얘도 메타 데이터를 저장할 수 있는 문법인데 UCLASS를 저장할 수 있습니다. 

	예를 들어서 Player 라는 클래스의 TsubclassOf 를 만들면 Bullet 이라는 클래스의 정보를 넣을 수 없게 됩니다. 
	TSubclassOf<Player> player;
	이렇게 만든 player 라는 TSubclassOf 는 Player를 상속받은 클래스들만 넣을 수 있도록 랩핑해놓은 클래스인겁니다. 

	마지막으로 Asset 이란 블루프린트, Sound 같은 완성된 객체를 저장하기위한 단위입니다. 

	그래서 GetAsset 함수를 다시 보겠습니다. 

	template<typename AssetType>
	inline AssetType* ULcAssetManager::GetAsset(const TSoftObjectPtr<AssetType>& AssetPointer, bool bKeepInMemory)
	{
		ULcAssetManager::StaticClass();

		AssetType* LoadedAsset = nullptr;
		const FSoftObjectPath& AssetPath = AssetPointer.ToSoftObjectPath();

		if (AssetPath.IsValid())
		{
			// 로딩이 되어있다? -> 바로 가져옴
			// 로딩이 안되어 있다 -> Null
			LoadedAsset = AssetPointer.Get();
			if (!LoadedAsset)
			{
				LoadedAsset = Cast<AssetType>(SynchronousLoadAsset(AssetPath));
				ensureAlwaysMsgf(LoadedAsset, TEXT("Failed to load asset [%s]"), *AssetPointer.ToString());
			}

			if (LoadedAsset && bKeepsInMemory)
			{
				// 여기서 AddLoadAsset은 메모리에 상주하기 위한 장치라고 생각하면 됨:
				// - 한번 등록되면 직접 내리지 않는한 Unload가 되지 않음 (== 캐싱)
				Get().AddLoadedAsset(Cast<UObject>(LoadedAsset));
			}
		}

		return LoadedAsset;
	}

	인자로 받은 AssetPointer 에서 FSoftObjectPath 를 추출해서 경로가 유효한지를 체크하고 이어서 AssetPointer를 .Get() 하고 있습니다. 이게 뭐냐면
	이 에셋이 로딩이 이미 되어있다면 바로 가져오고 로딩이 아직 안되있다면 null을 반환합니다. 
	그렇기 때문에 에셋이 로딩되어있는지를 확인하면서 로딩이 되어 있지 않다면 SynchronousLoadAsset을 실행하면서 동기 로딩을 진행합니다. 

	반면 bKeepInMemory 과 LoadedAsset 이 다 null 이 아니라면 Get().AddLoadedAsset 을 호출하는데 
	AssetManager의 Get은 싱글톤 패턴으로 GEngine에서 에셋매니저를 가져오는 함수였고 AddLoadedAsset 에서 LoadedAsset 은 위에서 UPROPERTY를 붙혀서 만들었던 
	TSet<TObjectPtr<const UObject>> LoadedAssets; 입니다. 
	결국 TSet 에 LoadedAsset 이라는 에셋을 추가하는건데 한번 래핑을 해둔겁니다. 
	AddLoadedAsset 함수를 보면 

	void ULcAssetManager::AddLoadedAsset(const UObject* Asset)
	{
		if (ensureAlways(Asset))
		{
			FScopeLock Lock(&SyncObject);
			LoadedAssets.Add(Asset);
		}
	}
	SyncObject 라는걸 락을 걸고 Add를 하고 있습니다. 

	락을 거는건 멀티스레드 환경에서 메모리침범을 막기위해 격리를 시키는 개념이었습니다. 

	PRAGMA_DISABLE_OPTIMIZATION
	void ULcAssetManager::StartInitialLoading()
	{
		Super::StartInitialLoading();
	}
	PRAGMA_ENABLE_OPTIMIZATION

	이런 함수를 하나 만들어 뒀었는데 StartInitialLoading 라는 줄에 중단점을 걸고 실행해봅니다. 
	그런데 그전에 언리얼엔진에서 기본 에셋매니저를 직접 만든 LcAssetManager 라고 설정을 해줘야하는데 프로젝트 세팅 -> AssetManager 에서 설정할 수 있습니다.

	처리후 프로젝트 실행을 해보면 언리얼 엔진 로딩중에 중단점이 걸리는걸 알 수 있습니다. 
	이게 무슨 의미냐면 컨텐츠작업을 진행하던 지금까지에서는 언리얼에서 멀티스레드 프로그래밍에대해 따로 생각하지 않아도 되도록 로직이 짜여있는데 
	예외가 있다면 에디터가 완전히 실행되기 전에는 멀티스레드가 세이프 하지않습니다. 그래서 LcAssetManager 의 코드에서는 락을 걸면서 스레드 세이프하게 코드를 짜야합니다. 

	그런데 LoadedAssets 라는 곳에 로딩을 해뒀던 에셋들을 왜 관리를 할까요 
	한번 로딩한 데이터들은 마음대로 삭제되면 안됩니다. 언제 다시 사용해야할지 모르기 때문인데 그런 에셋들을 TSet 에 담아서 관리하면 자동으로 메모리 해제가 되는걸 방지 할 수 있습니다. 
}


# 4 Experience
{
	Experience 라는것이 뭐냐면 Lyra 프로젝트의 근간을 이루는 개념입니다. 

	예를 들어서 FPS 모드를 진행하다 AOS 모드로 넘어갈때 게임모드를 변경합니다. 
	그런데 게임모드가 굉장히 무겁습니다. 무겁다는건 게임모드가 세팅하고 있는 양이 많다는겁니다. 왜 이렇게 됐냐면 
	언리얼엔진이 4버전에서 5버전으로 넘어와도 그동안 사용하던 코딩방식을 사용해도 전혀 문제가 없게끔 만든다고 하다가 게임모드가 가지고 있는 기능들이 많아진겁니다. 

	언리얼엔진에서 게임모드를 상속받아서 C++ 클래스를 만들려고 검색해보면 GameMode 상위에 GameModeBase 가 있습니다. 
	GameModeBase 는 그냥 게임모드보다 좀 더 가벼운 버전이라고 만든 것이지만 사실 이것도 무거운 편입니다. 

	그래서 라이라 프로젝트에서는 게임모드를 하나만 사용합니다. 게임모드를 교체하면서 사용하는게 아니라 동일한 하나의 게임모드만 사용하고 
	게임모드를 변경을 할때 Experience 라는 새로운 개념을 사용해 모드를 변경합니다. 

	즉, Experience 는 개임 모드를 대체하는 작은 게임모드라고 할 수 있습니다. 

	실습을 하기위해서 일단 게임모드가 하나는 있어야합니다. GameModeBase를 상속받아서 LcGameMode 라는 이름으로 C++ 클래스를 하나 생성해주겠습니다. Source 디렉토리 내에 GameModes 
	폴더를 하나 더 만들어 여기에 관리를 해주고 이어서 PrimaryDataAsset 을 상속받은 C++ 클래스를 하나 더 만들어줄건데 이름을 LcUserFacingExperience 라고 짓겠습니다. 
	한번더 PrimaryAsset 를 상속받은 LcExperienceDefinition 을 생성합니다. 마지막으로 다시 PrimaryAsset 를 상속받은 LcPawnData 클래스를 추가하는데 이건 Source/Character 디렉터리에 생성해주겠습니다.

	이 구조가 라이라 프로젝트에서 사용하는 구조라 따라했습니다. 

	이제 만든 파일들을 수정해볼건데 일단 아직 LcGameMode 는 건드리지 않을 겁니다. 
	건드릴건 먼저 LcUserFacingExperience 입니다. 이 Experience 라는게 위에서 예시를든 FPS, AOS 각각 모드 하나를 말하는겁니다. 

	지금 만든 파일들이 어떻게 동작하는지 대략 말해보겠습니다. LcUserFacingExperience 에서는 Map 과 Definition을 들고 있는데 Map 은 말그대로 소환사의 협곡같은 맵에 대한 데이터나 아이디 이고 
	Definition 은 다시 PawnData 를 들고 있습니다. PawnData 는 어떤 폰을 소환할건지 또 인풋을 어떻게 할건지 그리고 스킬같은 어빌리티는 어떤것들이 있는지를 가지고 있을겁니다. 
	이 것들을 다 위에서 만든 LcUserFacingExperience, LcExperienceDefinition, LcPawnData 들이 이것입니다. 

	LcPawnData 는 그냥 생성자만 만들고 생성자에선 Super(ObjectInitializer) 추가합니다. 
	LcExperienceDefinition 에서는 DefaultPawnData 와 GameFeaturesToEnable 을 들고 있는데 일단 DefaultPawnData 는 LcPawnData 을 말하는겁니다. 
	
	Experience 는 좀 더 가벼워진 게임모드인데 그에 필요한 데이터들도 들고 있는 형태이다 이정도로 이해하고 있으면 되겠습니다. 

	원래 게임모드를 설정할때 월드 세팅에서 게임모드를 설정했는데 이것을 None으로 두고 에디터의 프로젝트 세팅에서 GameMode 를 검색해서 여기를 LcGameModeBase 로 설정하는겁니다. 
	그래서 게임모드는 여기서 변화가 없고 앞으로는 Experience 로 모드를 변화하게끔 합니다. 
}


# 5 Map
{
	먼저 LcUserFacingExperience 를 구성하는 두가지 MapId, ExperienceId 중 Map 에 대해 알아보겠습니다. 

	라이라 프로젝트를 실행시켜보면 이제 각각 포탈로 표현되어있는 여러 게임 모드들이 이제 Experience 라는걸 알 수 있습니다. 정확히는 각각 UserFacingExperience 들입니다. 
	그리고 라이라 프로젝트의 Experience 중에서는 FrontEnd 라는 이름의 Experience 가 있는데 이건 게임모드가 아니라 게임에서 ESC 를 눌렀을때 화면, 로그인 화면 같은건데 
	Experience 는 단순히 게임모드뿐만 아니라 UI적 화면전환으로도 사용할 수 있다는걸 알 수 있습니다. 

	일단 이번에 이 Experience 들이 배치되어있는 맵 까지 만들어 보겠습니다. 

	Lc 프로젝트를 실행시켜서 콘텐츠 브라우저를 봅니다. 컨텐츠 폴더 아래로 System/DefaultEditormap 경로로 폴더를 만들고 여기에 새로 빈 레벨을 만듭니다. 
	위에서 창 옵션 버튼을 누르고 환경 라이트 믹서라는 설정창을 연 뒤 위에 뜨는 몇가지 버튼을 눌러 환경설정을 해줍니다. 다시 끄고 
	이제 레벨을 저장해주는데 L_DefaultEditorOverview 라는 이름으로 저장해줍니다. 

	다음은 바닥을 만들어줄건데 맵에 큐브를 추가한 후 로케이션을 모두 0으로 밀어준 후 스케일에서 x, y 값을 100 으로 설정해줍니다. 
	그러면 하얀 바닥이 생기는데 라이라에서는 바닥이 주황색이었는데 이것이 메테리얼입니다. 라이라 프로젝트를 실행해서 여기서 사용한 메테리얼을 가져올겁니다. 

	라이라 프로젝트의 바닥이 사용한 메테리얼을 우클릭 에셋 액션->이주 를 하는데 LC 프로젝트의 Content 폴더로 이주시킵니다. Content 가 아니면 이주가 안되거나 깨져서 이주되기도 합니다. 
	이제 LC 프로젝트의 바닥 메테리얼을 가져온걸로 설정해주고 프로젝트 세팅에서 시작맵과 기본맵을 L_DefaultEditorOverview 로 바꿔준 후 저장하면 
	맵은 준비가 되었습니다. 
}


# 6 ExperienceList3D
{
	이제 라이라의 기본 맵을 만들었으니 이제 각 Experience 를 나타내는 포탈같은 것들을 만들어보겠습니다. 
	위에서 Experience 파일들을 만들었을때 가장 먼저 만들었던 ULcUserFacingExperience 가 상속한 클래스를 보면 UPrimaryDataAsset 입니다. 즉 데이터 파일에 불과 하다는거고 
	실제 사용되는곳이 어딘지 보면 ULcAssetManager 의 부모 클래스인 AssetManager 를 따라 들어가 설명을 읽어보면 싱글톤 패턴이면서 PrimaryAsset 을 로딩할지 언로딩할지를 
	응답한다고 되어있습니다. 
	즉, 저번에 에셋매니저를 만들면서 동기적 혹은 비동기적으로 로딩해 사용하게 만들었는데 그래도 상관은 없지만 언리얼에서 의도한 대로 PrimaryAsset 을 사용하면 많이 편리합니다. 
	PrimaryAsset 은 데이터의 묶음인데 이걸 편하게 로딩할 수 있는것입니다. 

	LcUserFacingExperience 파일을 언리얼엔진에서 사용하려면 엔진을 실행하고 콘텐츠 드로어에서 Playlists 폴더에다가 파일을 하나 추가해야합니다. 우클릭->기타->데이터에셋을 클릭한 후 
	LcUserFacingExperience 을 검색해 파일을 만들면 됩니다. PrimaryAsset 이 DataAsset 을 상속 받았기 때문에 이렇게 만들어 집니다. 
	이름을 DA_ExamplePlaylist 라고 짓고 테스트를 해볼건데 여기에 LcUserFacingExperience 의 멤버 변수들인 MapId, ExperienceId 를 설정할 수 있습니다. 
	하지만 MapId 를 설정하려고 보니 이전에 만들었던 맵인 L_DefaultEditorOverview 맵이 보이지 않습니다.
	그래서 스캔이라는 개념을 배워야합니다. 

	스캔이란 에셋매니저가 사용하기 위해 주시를 하고 있는것을 스캔이라고 합니다. 
	그러면 스캔과 로딩이 비슷하게 보입니다. 하지만 완벽하게 다른 개념입니다. 
	로딩은 어떤 에셋의 크기가 작을지 클지 모르기도 하고 RAM에 모든 에셋들을 다 올려놓지 못하니깐 엔진에서는 그냥 에셋의 경로만 알고 있고 사용할때 그 경로의 에셋을 가져오는것입니다. 
	이때 에셋의 경로로 이 에셋을 주시하고 있다고 할 수 있습니다. 
	스캔도 에셋매니저가 이 에셋이 존재한다는 것을 알고만 있는것입니다. 

	스캔은 어떻게 하냐면 언리얼 에디터의 프로젝트 세팅으로 가보면 에셋매니저 설정창이 있습니다. 이중에 스캔할 프라이머리 에셋 타입 창을 펼쳐서 설정합니다. 
	이 중에 인덱스를 열어보면 프라이머리 에셋 타입이 Map 으로 되어있고 에셋 베이스 클래스가 World 입니다. 그리고 그 밑에 디렉터리와 특정 에셋이라는 옵션이 있는데
	특정 옵션은 정말 딱 지정한 하나의 에셋을 스캔하는것입니다. 하나하나 직접 스캔하도록 설정하는 방법이기 때문에 너무 번거롭다면
	디렉터리 옵션을 보면되는데 이 옵션은 어떤 폴더를 지정하면 그 폴더 아래에 있는 에셋을 스캔합니다. 

	그런데 라이라 프로젝트에서는 맵을 특정 에셋 방식으로 스캔하고 있기 때문에 이대로 따라하겠습니다. 
	설정한 후 아까 만들었던 DA_ExamplePlaylist 의 MapId 를 살펴보면 스캔이 되어 있는걸 확인 할 수 있습니다. 

	Map은 설정했고 이어서 ExperienceId 를 설정해볼겁니다. 
	LcUserFacingExperience 를 상속받은 DA_ExamplePlaylist 는 DataAsset 으로 만들었지만 Experience 는 블루 프린트로 만들어야합니다. 
	블루프린트생성할때 LcExperienceDefinition 를 상속받아 만들어 줍니다. 이름은 B_LyraDefaultExperience 라고 하겠습니다. 열어보면 설정할 수 있는 변수가 Default Pawn Data 가 있습니다. 
	B_LyraDefaultExperience 를 DA_ExamplePlaylist 에서 스캔하려면 다시 프로젝트 세팅의 에셋매니저에서 스캔할 프라이머리 에셋 타입을 하나 추가해 프라이머리 에셋 타입 에셋 베이스 클래스 
	둘다 LcExperienceDefinition 으로 설정해줍니다. 그리고 그 밑에 블루프린트 클래스 보유 옵션을 활성화 합니다. 그리고 나서 언리얼 에디터를 재 실행한 후 디렉터리를 B_LyraDefaultExperience가
	위치한 System/Experiences 로 설정하면 이제 DA_ExamplePlaylist의 ExperienceId 에 스캔이 됩니다. 
	/* 저의 경우 스캔이 안됐었는데 왜냐면 LcUserFacingExperience.h 파일에서 ExperienceId 를 선언할때 UPROPERTY 의 인자중에 meta allowtype을 오타를 내서 인식이 안됐습니다. */
	
	이제 정리하자면 DA_ExamplePlaylist 라는 이름으로 UserFacingExperience 가 있고 이 안에서 MapId 로 L_DefaultEditorOverview 를 스캔해 넣고 ExperienceId 로 B_LyraDefaultExperience 
	를 스캔해 넣었습니다. 

	Content/System/DefaultEditormap 에 B_ExperienceList3D 라는 블루프린트가 있는데 이 블루프린트의 역할은 DA_ExamplePlaylist 라고 만들었던 UserFacingExperience 이것들이 몇개나 있는지
	보고 그만큼을 맵에 소환해 줄겁니다. 지금은 한개 밖에 없는데 더 많아 지면 그 숫자 만큼 소환을 해줄겁니다. 
	변수를 추가할건데 LcUserFacingExperience 를 리스트 형식으로 추가해서 UserFacingExperienceList 라는 이름의 변수로 들고 있을 겁니다. 그리고 Float 타입으로 PortalSpacing 이라고 들고 있겠습니다.
	UserFacingExperienceList는 DA_ExamplePlaylist 같은 Experience 들을 담아두는 배열이고 PortalSpacing은 각 포탈간의 간격을 말합니다. PortalSpacing 값은 500.0f 로 설정하겠습니다. 

	B_ExperienceList3D 에서 가장먼저 할 건 프로젝트가 가지고 있는 Experience 들을 다 가져와 UserFacingExperienceList 에 담아놔야 이후 관리를 시작할겁니다. 
	그 전에 혹시 남아 있을 쓰레기 값을 다 비워주고 시작하면 좋겠습니다. 블루프린트의 BeginPlay 에서 UserFacingExperienceList 의 Clear 노드를 연결해 밀어줍니다. 
	다음 노드로 Get Primary Asset Id List 라는 노드를 호출할겁니다. 이 함수는 Map, LcExperienceDefinition, PrimaryAssetLabel 카테고리를 골라 그에 해당하는 파일들을 다 긁어옵니다. 
	이 카테고리들은 프로젝트 세팅 -> 에셋 매니저 에서 스캔하기 위해 추가했던 카테고리들입니다. 

	여기서 이 카테고리중 우리가 추가하고 싶었던 LcUserFacingExperience 은 없는걸 알 수 있는데 이제는 자연스럽게 스캔하도록 카테고리를 추가하면 됩니다. 
	이제 Get Primary Asset Id List 함수에 LcUserFacingExperience 가 뜨는걸 볼 수 있는데 여기까지는 로딩까지 진행한게 아니라 스캔까지만 진행된겁니다. 
	로딩을 해줄겁니다. 

	로딩함수는 Async Load Primary Asset List 입니다. Async 는 비동기 방식이라는건데 비동기 방식은 함수가 완료되는걸 기다리지 않고 따로 코드 진행이 된다는 뜻이었습니다. 
	그래서 이 함수 노드에는 Complete 라는 화살표가 있는게 따로 함수가 완료되면 진행되는 화살표인겁니다. 
	Complete 가 되면 이어서 Foreach Loop 를 하면서 가져온 LcUserFacingExperience 들을 모두 로딩해 가져올거고 이어서 LcUserFacingExperience 로 캐스팅하고 UserFacingExperienceList 에 담아줍니다.

	리스트를 다 채운 후에는 이제 그 Experience 들을 포탈로 만들어줘야합니다. 스캔하고 로딩한 후의 for each 문의 complete 화살표를 이어서 진행하면 리스팅이 다 끝난 후의 코드입니다. 
	여기서 다시 UserFacingExperienceList 를 대상으로 foreach 를 돕니다. 

	그리고 생성할 포탈 액터를 만들어줘야하는데 액터를 상속받아서 이름을 B_TeleportToUserFacingExperience 라고 짓겠습니다. 안에서 스태틱 메쉬와 캡슐 콜리전을 추가해줍니다. 
	여기서 에셋이 필요하기 때문에 라이라 프로젝트에서 가져옵니다. B_TeleportToUserFacingExperience 를 검색해보면 블루프린트가 나오고 여기서 이중에 발판만 Lc 프로젝트에 이주해 오겠습니다. 

	에셋을 이주해 온 뒤 한번 에디터를 껏다 켜야할겁니다. 
	재부팅하고 난 뒤엔 B_TeleportToUserFacingExperience에서 추가해 뒀던 Static Mesh 를 이주해온 메쉬로 설정하고 캡슐 콜리전은 Location을 (0, 0, 100) 으로 설정하고 
	셰이프의 높이 너비를 80씩으로 설정합니다. 
	그리고 변수를 하나 가지고 있어야하는데 UserFacingExperience 를 가지고 있어야합니다. 포탈이 UserFacingExperience 을 가지고 있어야 이 포탈에 부딛힌 캐릭터를 해당 Experience로 보낼 수 
	있기 때문입니다. 이때 변수 옆에 눈 모양을 띄워줘야 c++에서 public 으로 만드는것과 같이 외부에서 수정할 수 있습니다. 그리고 디테일즈에서 이 변수를 스폰시 노출하도록 설정합니다.

	돌아와서 B_ExperienceList3D 에서 다시 변수를 하나 추가합니다. 포탈들을 리스트로 관리하겠습니다. 
	B_TeleportToUserFacingExperience 를 리스트 변수로 하나 만들고 아까 foreach 를 돌면서 매 시행마다 B_TeleportToUserFacingExperience 액터를 스폰한 후 로드했던 Experience를 추가해줍니다. 
	B_TeleportToUserFacingExperience 를 스폰할때 그 위치를 지정해줘야합니다. 적절한 로직으로 맵중앙으로 부터 UserFacingExperience 가 늘어 날때 마다 좌우로 위치하도록 만들어 Location 값을 
	SpawnActor 에 넘겨주면 됩니다. 
}

# 7 Experience Load
{
	맵을 만들고 Experience 의 뼈대를 만들어 그 포탈을 스폰하는 것까지는 했습니다. 
	이어서 Experience 를 로드 하는 내용을 알아 보겠습니다. 

	이전에 라이라 프로젝트에서는 하나의 게임모드를 계속 사용하고 그 안에서 Experience 라는 가벼운 모드를 가지고 전환하면서 실행된다고 했는데 
	그런데 사실은 여기에 더해 GameState, PlayerState, PlayerController, Character 이런것들 까지 만들어 놓고 시작합니다. 
	
	이 네가지들도 기본이 되는 개념들을 박아두고 안변하는 대신에 그 아래로 각각 필요한 부품들을 갈아 끼웁니다. 

	GameState 라는것은 GameMode 와 1대1 대응이 되고 그 부품으로 ExperienceManagerComponent 를 가지고 있으면서 이 컴포넌트가 로딩을 담당하고 
	로딩이 끝나면 응답을 해서 로딩이 끝났으니 다음 코드로 진행하라고 신호를 줍니다. 
	Experience 의 경우 원래 C++ 에 포함된 개념이 아니다 보니 그 흐름을 제어하기가 힘든데 이 ExperienceManagerComponent 에서 직접 로딩과 그 후 진행까지 
	맡아주는겁니다. 

	PlayerState 에서는 안에 PawnData를 캐싱해둘 건데 이 안에는 당연히 있어야 할 정보들이 있습니다. 어떤 폰을 스폰할지나 인풋은 어떻게 할지 그리고 카메라 모드같은것도 가지고 있습니다. 
	카메라 모드가 뭔가하면 보통 언리얼엔진을 배울때 플레이어 캐릭터에는 로컬 좌표로부터 일정거리를 뜻하는 스프링 암 개념이 있고 여기에 카메라를 아래로 붙여서 카메라를 달고 다녔습니다.
	그런데 라이라에서는 스프링 암이라는 개념이 없습니다. 
	카메라 모드가 대신하는데 지금 저격수 카메라 모드, 일반 카메라 모드, 공중 카메라 모드 등 을 사용해 카메라 형식을 바꿉니다. 

	PlayerController는 아래로 CameraManager 가 있습니다. CameraManager 와 Player가 들고 있던 CameraComponent 는 연관이 있습니다. 
	카메라 컴포넌트를 통해 화면을 보는데 렌더링은 카메라 매니저에서 렌더링을 해줍니다. 
	왜 이렇게 되어있냐면 라이라에서 캐릭터가 모두 플레이어는 아니기 때문입니다. 라이라에서 캐릭터는 동물이나 몬스터 엔피씨 일 수도 있는데 컨트롤러는 플레이어한테만 붙을 것이기 때문입니다. 

	그래서 이렇게 GameState, PlayerState, PlayerController, Character 네가지를 만들어보겠습니다. 

	기본 C++ 파일들 부터 만들겠습니다. Character 는 언리얼에디터에서 C++ 파일 추가로 Character 를 상속받아 LcCharacter 정도로 만들면 됩니다 생성 경로는 Source/Lc5_5/Character로 설정합니다.
	GameState는 GameStatebase 를 상속받고 GameMode 디렉터리로 설정합니다. PlayerController는 PlayerController 를 상속받고 Source/Lc5_5/Player 디렉토리를 만들고 거기로 생성하게 설정해줍니다.
	PlayerState 도 역시 PlayerState를 상속받고 Player 디렉토리 아래로 생성합니다. 

	다음은 LcGameModeBase 코드로 가서 생성자를 만들어 주고 생성자에서 초기화를 몇가지 해줄겁니다. 
	
	ALcGameModeBase::ALcGameModeBase()
	{
		GameStateClass = ALcGameState::StaticClass();
		PlayerControllerClass = ALcPlayerController::StaticClass();
		PlayerStateClass = ALcPlayerState::StaticClass();
		DefaultPawnClass = ALcCharacter::StaticClass();
	}
	이전에 언리얼 에디터에서 기본 게임모드를 LcGameModeBase 로 설정을 했었는데 그 내부의 기본 GameState,PlayerController,PlayerState,DefaultPawn 들을 지금 설정한 클래스들로 기본설정이 됩니다.
	실제로 에디터를 실행해서 프로젝트 설정->맵&모드 를 가보면 지금 설정한 클래스로 바뀌어있습니다. 라이라 프로젝트에서는 이렇게 시작을 합니다. 

	그러면 이제 의문이 생기는데 Experience 로 여러 게임들을 변경하는게 라이라 프로젝트였는데 지금처럼 기본 클래스들을 고정으로 박아두고 시작하면 어떻게 Experience 에 따라 변경할지가 궁금해집니다. 

	언리얼엔진이 실행되는 과정을 보면 GameInstance 가 가장 먼저 생성이 되고 World 만든 후에 Level, GameMode 순으로 생성이 됩니다. 각 모듈이 생성되는 순서 말고 호출되는 함수도 순서가 있는데 
	InitializeActorForPlay->InitGame 이라는 함수들을 가장 먼저 호출합니다. 아직 월드에 액터들을 스폰하기도 전입니다. 이 InitGame 함수를 오버라이드로 GameMode에 받아서 몇가지 초기화를 하겠습니다. 

	LcGameModeBase 클래스 안에 	
	virtual void InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage) override;
	이런 시그니처로 멤버 함수를 만들고 안에 
	Super::InitGame(MapName, Options, ErrorMessage);
	이 슈퍼 함수를 호출해주면 일단 오버라이딩 준비가 되었습니다. 여기에 추가로 새 함수를 만들어 호출할건데 그 함수 이름은 
	void HandleMatchAssignmentIfNotExpectingOne();
	입니다. 
	이 함수의 역할은 우리가 라이라 게임 만들면서 포탈을 타는 방식으로건 어떻게든 Experience를 선택하게 되는데 선택한 Experience 를 ExperienceManager 에서 로딩을 시작할겁니다. 
	이때 로딩뿐만 아니라 데디케이트 서버가 맞는지, 개발자의 옵션 설정인지 등등 여러가지 요소들을 전부 검사해서 매치를 해줍니다. 그래서 함수 이름이 HandleMatchAssignmentIfNotExpectingOne
	인겁니다. 
	하지만 제가 만들 프로젝트에서는 그냥 ExperienceLoading 을 선택하는 용도로만 쓸거기 때문에 조금 다르지만 일단은 기존 라이라 프로젝트를 따라 만들것이기 때문에 이 이름을 사용합니다.

	그러면 HandleMatchAssignmentIfNotExpectingOne 과 함께 호출할 ExperienceLoading 을 언제 진행할것인가를 생각해보면 바로 InitGame 에서 호출해줄겁니다. 

	void ALcGameModeBase::InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage)
	{
		Super::InitGame(MapName, Options, ErrorMessage);

		// 아직 GameInstance를 통해, 초기화 작업이 진행되므로, 현 프레임에는 Lyra의 Concept인 Experience 처리를 진행할 수 없다:
		// - 이를 처리하기 위해, 한프레임 뒤에 이벤트를 받아 처리를 이어서 진행한다
		GetWorld()->GetTimerManager().SetTimerForNextTick(this, &ThisClass::HandleMatchAssignmentIfNotExpectingOne);
	}
	보면 World 를 가져오고 또 거기서 TimerManager의 SetTimerForNextTick 함수에서 HandleMatchAssignmentIfNotExpectingOne 를 호출하고 있습니다. SetTimerForNextTick 라는 함수가 무슨 함수나면
	지금 말고 다음 프레임때에 인자로 준 함수를 실행해달라는겁니다. 
	왜 굳이 다음 프레임에 실행하도록 했냐면 다시 언리얼엔진의 요소들이 로딩되는 순서를 봐야하는데 InitGame 이라는 함수가 엔진의 굉장히 초기에 호출된다고 했었습니다.
	그러다 보니 첫프레임 시점의 InitGame 에서는 다른 요소들이 거의 없습니다. 그리고 우리가 하려고 했던것도 Experience 로딩인데 이건 ExperienceManager 에서 로딩한다고 했는데 당연히 
	첫프레임 InitGame 에는 아직 객체가 생성되지 않았습니다. 그래서 SetTimerForNextTick 로 한 프레임 다음에 로딩을 해주는겁니다. 

	막상 아직 ExperienceManager를 만들지 않았습니다. 그러기 위해서 엔진을 실행한 후 몇가지 설정을 해야합니다. ExperienceManager 라는 것은 GameStateComponent 가 필요합니다. 
	이건 플러그인을 추가해야하는데 위의 옵션중에 프로젝트 세팅 밑에 플러그인을 관리하는 옵션이 있습니다.
	여기서 Modular Gameplay 를 활성화 시킵니다. 그리고 지금은 아닌데 나중에 프로젝트에 필요한 Game Features 플러그인도 지금 활성화 시키겠습니다. 마지막으로 Gameplay Abilities 까지 
	활성화를 해주면 되겠습니다. 

	플러그인을 추가하고 또 LC_5_5.bulid.cs 파일의 코드를 수정해야 우리가 C++ 로도 관리 할 수 있습니다. 

	PublicDependencyModuleNames.AddRange(new string[]  {
		"Core",
		"CoreUObject",
		"Engine",
		"InputCore",
		// GAS
		"GameplayTags",
		// Game Features
		"ModularGameplay",
		"GameFeatures",
	});
	
	이러고 나서 다시 엔진을 실행시켜봅니다. 

	C++ 클래스를 추가하는데 GameStateComponent 를 상속받게끔 해주고 이름을 LcExperienceManagerComponent 라고 짓습니다. 그리고 GameModes 폴더에 생성합니다. 
	이게 ExperienceManager 가 되는겁니다. 

	GameStateComponent는 어떤 것에 부착할 수 있게 해줍니다. 코드를 상위 클래스로 따라 올라가다 보면 UActorComponent 이것도 엑터에 부착할 수 있는 컴포넌트입니다. 
	GameState 에 추가로 붙힐 수 있는 Component 라서 GameStateComponent 입니다. 

	이런 컴포넌트 개념은 언리얼보다는 유니티 엔진에서 더 많이 사용하는 개념인데 이걸 GameFeatures 모듈로 가능하도록 만든겁니다. 이 구조의 장점은 확장성이 좋고 
	단점은 디버깅이 힘들고 파일이 많아서 가독성이 떨어진다는겁니다. 

	ExperienceManagerComponent는 GameStateComponent 이기 때문에 당연히 GameState에서 들고 있을겁니다. 우리가 만든 LcGameState 에서 들고 있을겁니다. 
	LcGameState 에서 LcExperienceManagerComponent 를 TObjectPtr 로 들고 있고 GameState 의 생성자에서 CreateDefaultSubobject 로 객체를 생성해줍니다. 

	이제 GameState에 컴포넌트를 부착은 했는데 아무런 설정을 하지 않았습니다. 

	LcExperienceManagerComponent 가 뭘 들고 있을지를 생각해보면 이 클래스가 할 일은 Experience를 로딩하는 클래스이다 보니 로딩할 클래스를 들고 있을겁니다. 
	이때 Experience를 들고 있다고 해서 로딩이 완료 되었다는 뜻은 아닙니다. 이 로딩이 완료되는 시점을 알아야 해당 Experience로 전환을 하는데 완성시점을 알려주는 C++ 문법이 
	델리게이트 입니다. 

	LcExperienceManagerComponent.h 파일 위쪽에 현재 가지고 있는 Experience의 로딩 상태를 enum class 를 선언합니다. 
	enum class ELcExperienceLoadState
	{
		Unloaded,
		Loading,
		Loaded,
		Deactivating,
	};

	그리고 Delegate를 언리얼에서 하는방법은 
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnLcExperienceLoaded, const ULcExperienceDefinition*);
	이 매크로로 하나의 매개변수를 가지는 멀티캐스트 델리게이트를 선언합니다. 매개변수는 아까 만들었던 LcExperienceManagerComponent 가 들고 있을 Experience 입니다. 
	첫번째 인자로 준 FOnLcExperienceLoaded 는 이제 const ULcExperienceDefinition* 를 인자로 받는 멀티캐스트 델리게이트 클래스로 선언이 된겁니다. 

	그래서 이제 총 세가지 멤버 변수를 들고 있을 겁니다. 첫째로 로딩할 현재 Experience, 두번째로 Experience 가 현재 어떤 상태인지를 나타내는 ELcExperienceLoadState,
	세번째는 Experience 를 델리게이트할 FOnLcExperienceLoaded 입니다.

	public:
	UPROPERTY()
	TObjectPtr<const ULcExperienceDefinition> CurrentExperience;

	/** Experience의 로딩 상태를 모니터링 */
	ELcExperienceLoadState LoadState = ELcExperienceLoadState::Unloaded;

	/** Experience 로딩이 완료된 이후, Broadcasting Delegate */
	FOnLcExperienceLoaded OnExperienceLoaded;

	이제 함수를 하나 만들겁니다. 

	bool IsExperienceLoaded() { return (LoadState == ELcExperienceLoadState::Loaded) && (CurrentExperience != nullptr); }
	이 함수는 지금 Experience 가 로딩이 됐는지를 체크하는 함수인데 LoadState 가 Loaded 이고 CurrentExperience가 nullptr 이 아닌지를 체크 해주는겁니다. 
	
	또 한가지 함수를 더 만들건데
	void CallOrRegister_OnExperienceLoaded(FOnLcExperienceLoaded::FDelegate&& Delegate);
	이 함수는 델리게이트를 걸어주는 함수입니다. 

	사실 델리게이트는 아까 만든 델리게이트 객체에 델리게이트를 추가해주면 로딩이 됩니다. 무슨 말이냐면 
	OnExperienceLoaded.Add(Delegate);
	이렇게 해주면 끝인데 굳이 하나 더 래핑해서 사용할까요
	
	void ULcExperienceManagerComponent::CallOrRegister_OnExperienceLoaded(FOnLcExperienceLoaded::FDelegate&& Delegate)
	{
		// IsExperienceLoaded() 구현
		if (IsExperienceLoaded())
		{
			Delegate.Execute(CurrentExperience);
		}
		else
		{
			/**
			* 참고로, 여러분들은 Delegate 객체를 자세히 살펴보면, 내부적으로 필요한 변수들은 메모리 할당해놓는다:
			* TArray<int> a = {1, 2, 3, 4};
			* delegate_type delegate = [a](){
			*	return a.Num();
			* }
			* a는 delegate_type 내부에 new로 할당되어 있다. 복사 비용을 낮추기 위해 Move를 통해 하는 것을 잊지 말자!
			*/
			OnExperienceLoaded.Add(MoveTemp(Delegate));
		}
	}
	이런 코드인데 살펴보면 일단 Experience 가 로드된 상태인지를 체크해 로드 되어있으면 바로 Delegate.Excute(CurrentExperience); 를 호출해주고 
	만약 로드가 안되어 있다면 그러면 그때 델리게이트에 추가를 해주는겁니다. 
	그냥 무분별적으로 델리게이트에 추가하는게 아니라 로딩 여부를 한번 체크해 걸러주는겁니다. 

	이 CallOrRegister_OnExperienceLoaded 함수 이름을 다시보면 호출하거나 예약한다. OnExperienceLoaded 를 이라는 이름입니다. 직관적입니다. 
	어디서 이 함수를 호출해야 할까요 LcGameModeBase 로 가서 위에서 오버라이드로 만들었던 InitGame 함수 말고 InitGameState 도 만들어줄겁니다. 
	GameState를 초기화 하는 함수이기 때문에 이 함수가 호출되는 시점은 일단 GameState 가 일단 생성된 후에 호출될겁니다. 
	GameState가 생성 되었다는것은 GameState의 생성자에서 LcExperienceManagerComponent 를 생성했다라는겁니다. 그렇다는것은 InitGamestate 를 호출하는 시점에서는 
	LcExperienceManagerComponent::CallOrRegister_OnExperienceLoaded 를 호출 할 수 있다는 말입니다. 
		
	void ALcGameModeBase::InitGameState()
	{
		Super::InitGameState();

		// Experience 비동기 로딩을 위한 Delegate를 준비한다:
		ULcExperienceManagerComponent* ExperienceManagerComponent = GameState->FindComponentByClass<ULcExperienceManagerComponent>();
		check(ExperienceManagerComponent);

		// OnExperienceLoaded 등록
		ExperienceManagerComponent->CallOrRegister_OnExperienceLoaded(FOnLcExperienceLoaded::FDelegate::CreateUObject(this, &ThisClass::OnExperienceLoaded));
	}
	ULcExperienceManagerComponent 를 찾을때 GameState->FindComponentByClass 라는 함수로 ULcExperienceManagerComponent를 찾고 있습니다. 이 함수는 컴포넌트에 한해서 템플릿으로 준 클래스를 
	상속하고 있는 객체를 반환합니다. 
	그리고 혹시 모르니깐 한번 check를 해주고 이어서 CallOrRegister_OnExperienceLoaded 로 델리게이트를 걸어줍니다. 
	델리게이트를 할때 ThisClass::OnExperienceLoaded 가 아직 안만들어져있어서 만들어주겠습니다. 

	void ALcGameModeBase::OnExperienceLoaded(const ULcExperienceDefinition* CurrentExperience)
	{
	}
	아직 함수의 내용은 안만들었는데 일단 이 상태에서 InitGameState에서 델리게이트를 걸때의 흐름을 다시 보면 FOnLcExperienceLoaded::FDelegate::CreateUObject(this, &ThisClass::OnExperienceLoaded)
	이런 델리게이트를 겁니다. 이 델리게이트가 인자로 들어가고 로딩이 완료된 상태면 즉시 .Excute 를 하면서 OnExperienceLoaded 를 호출합니다. 

	여기서 알 수 있는건 GameMode에서는 Experience가 로드가 된 시점을 알 수는 없고 델리게이트를 걸어두고 OnExperienceLoaded 가 호출된 시점에 로딩을 진행하는겁니다. 

	다음으로 할 일은 PawnData를 채우는 건데 이때 생각해야 하는게 Pawn을 생성하고 데이터를 채우는 시점입니다. 
	지금까지 진행한 건 언리얼엔진을 시작하고 InitGame 을 호출하는데 InitGame에서는 다음 프레임에 HandleMatchAssignmentIfNotExpectingOne 라는 함수를 호출해줄겁니다. 
	이후 GameMode 가 생성되고 GameState 도 생성이 됩니다. GameState의 생성자에서 ExperienceManagerComponent 를 생성해 들고 있을겁니다. 다시 GameMode로 돌아와 InitGameState 를 호출합니다. 
	여기서 CallOrRegister_OnExperienceLoaded 로 델리게이트를 걸어줍니다. 여기서 그 다음으로 SpawnPlayerActor, login, SpawnPlayerController, InitPlayerState 순으로 호출을 하고 
	Player의 기본정보들을 초기화하는 함수들이 호출이 되는데 이때 PlayerState를 찾게되는데 초기화 함수들이 호출되는 시점에 PlayerState가 없다면 PlayerState가 생성되는 시점을 알아서 찾아서 
	호출이 됩니다. 그리고 기본 Pawn을 설정하고 그 후 HandleStartingNewPlayer_Implementation 을 호출하면서 그 플레이어의 정보를 세팅해주게 됩니다. 

	근데 이 흐름에서 CallOrRegister_OnExperienceLoaded로 델리게이트를 신청을 했는데 SpawnPlayerActor 부터 HandleStartingNewPlayer_Implementation 까지 호출하는게 한 프레임입니다. 
	하지만 CallOrRegister_OnExperienceLoaded을 해놨던 Experience가 그 한프레임 내에 로딩이 됐을리가 없습니다. 원하는건 Experience 가 로딩이 되서 그 안에 있는 데이터로 플레이어를 
	스폰하기를 원합니다. 

	그렇게 하기 위해서 플레이어스폰 이하의 함수들을 오버라이딩으로 만들어 Experience 가 로딩될때까지 막아둘겁니다. Experience 로딩이 된 후 맨 마지막에 ReStartPlayerAtPlayerStart 라는 함수를 호출해주면서 
	SpawnPlayerActor 시점부터 다시 시작하도록 하는게 지금 Experience 로딩 코드의 큰 흐름입니다. 

	지금 해볼건 PawnData를 PlayerState에서 저장하고 있을겁니다. 

	virtual void PostInitializeComponents() final;

	void OnExperienceLoaded(const ULcExperienceDefinition* CurrentExperience);

	UPROPERTY()
	TObjectPtr<const ULcPawnData> PawnData;
	
	일단 이렇게 3가지를 추가했습니다. 그런데 여기서 한가지 의문이 들 수 있습니다. PawnData 를 PlayerState에서 또 관리를 해야하나 라는 생각이 들 수 있는데 PlayerState 전에 
	LcExperienceDefinition 에서 이미 DefaultPawnData 라고 PawnData를 이미 들고있기 때문입니다. 

	왜 PlayerState 에서 따로 PawnData를 관리하고 있냐면 나중에 여기서 GameAbilitySystemComponent 라는 것을 만들어 붙혀 줄겁니다. 이게 능력같은걸 부여할 수 있는 컴포넌트라고 할 수 있는데 
	PlayerState 의 PawnData 를 참조해서 GameAbilitySystemComponent 가 능력을 부여 할것 입니다. 

	추가한 함수들을 보면 PostInitializeComponents 에서는 초기화가 완료된 시점이고 OnExperienceLoaded 함수는 Experience 가 로딩이 완료된 후에 PawnData 를 캐싱할것이기 때문에 있습니다. 
		
	void ALcPlayerState::PostInitializeComponents()
	{
		Super::PostInitializeComponents();

		const AGameStateBase* GameState = GetWorld()->GetGameState();
		check(GameState);

		ULcExperienceManagerComponent* ExperienceManagerComponent = GameState->FindComponentByClass<ULcExperienceManagerComponent>();
		check(ExperienceManagerComponent);

		ExperienceManagerComponent->CallOrRegister_OnExperienceLoaded(FOnLcExperienceLoaded::FDelegate::CreateUObject(this, &ThisClass::OnExperienceLoaded));
	}
	PostInitializeComponents 함수를 읽어보겠습니다. 월드로 부터 GameState를 추출해와서 GameState 라는 변수를 만들고 유효성을 체크합니다. 
	그리고 나서는 Experience를 로딩하는 클래스인 ULcExperienceManagerComponent도 추출해와서 ExperienceManagerComponent 라는 이름의 변수로 만듭니다. 이것역시 체크를 하고 
	ExperienceManagerComponent의 멤버 함수 CallOrRegister_OnExperienceLoaded는 델리게이트를 거는 함수였습니다. 만약 이미 로드 되어있다면 바로 처리하고 아니라면 비동기 방식으로 호출하고 있었습니다. 

	다음은 PawnData 를 조금 구성해보겠습니다. 
	UCLASS()
	class LC_5_5_API ULcPawnData : public UPrimaryDataAsset
	{
		GENERATED_BODY()
	public:
		ULcPawnData(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());

		/** Pawn의 Class */
		UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Lc|Pawn")
		TSubclassOf<APawn> PawnClass;
		
	};
	이렇게 PawnClass 를 만든 다음 언리얼에디터를 실행해보겠습니다.

	컨텐츠 드로워창에서 Characters/Heroes 위치에 LcCharacter 를 상속받은 블루프린트를 생성해줍니다. B_SimpleHeroPawn 이라고 짓고 메시에 실린더 스피어 를 추가해 대충 사람처럼 만들었습니다.
	이 폰의 데이터는 LcExperienceDefinition를 상속받았던 B_LyraDefaultExperience 에서 데이터를 관리하다 초기화를 해줄건데 아직 안들고 있습니다. 
	이걸 추가하기 위해 다시 Characters/Heroes/SimplePawnData 디렉토리를 하나 추가하고 여기에 데이터 에셋을 하나 만들건데 Lc Pawn Data 를 상속받아서 SimplePawnData 이름으로 만들어주었습니다. 
	이러면 위에서 추가했던 PawnClass 를 설정할 수 있는데 이걸 B_SimpleHeroPawn 로 설정합니다. 

	이 상태에서 B_LyraDefaultExperience 로 가면 Default Pawn Data 를 방금 만든 SimplePawnData 로 설정 할 수 있게 됩니다.

	여기까지의 구조를 다시 보자면 DA_ExamplePlaylist 에서 MapId는 L_DefaultEditorOverview, ExperienceId는 B_LyraDefaultExperience 로 설정이 되고 
	B_LyraDefaultExperience 에는 Default Pawn Data로 SimplePawnData가 설정이 되어있습니다. 또 따라가서 SimplePawnData 에서는 B_SimpleHeroPawn 가 PawnClass 로 설정이 되어있다는 겁니다. 

	이 시점에서 게임을 실행시켜서 보면 포탈만 스폰되어있는 맵이 뜨는데 아웃라이너를 살펴보면 Lc Character가 스폰이 되어있습니다. 왜 이러냐면 
	라이라 실행 순서를 봤을때 Experience 가 아직 로딩이 안되도 SpawnPlayerActor 가 호출되어서 인데 이 이하 부분을 Experience 가 로딩된 후 부터  호출되도록 막아주도록 하고 하겠습니다. 

	LcGameModeBase로 와서 두가지 함수를 만들겁니다. 
	
	/* HandleStartingNewPlayer */
	virtual void HandleStartingNewPlayer_Implementation(APlayerController* NewPlayer) final;

	/* SpawnDefaultPawnAtTransform */
	virtual APawn* SpawnDefaultPawnAtTransform_Implementation(AController* NewPlayer, const FTransform& SpawnTransform) final;

	HandleStartingNewPlayer_Implementation 함수는 블루프린트로도 사용가능하고 C++에서도 가능합니다. 그런데 뒤에 _Implementation 이 붙어 있으면 C++을 우선적으로 사용하고 아니라면 블루프린트로 사용합니다.
	HandleStartingNewPlayer_Implementation 에서는 현재 Experience가 로딩이 됐는지를 체크하고 로딩이 됐을경우에 기존 Super::HandleStartingNewPlayer_Implementation을 하도록 하면됩니다. 
	이 Experience 가 로딩이 되었는지를 체크하는건 LcExperienceManagerComponent::IsExperienceLoaded 에서 확인 할 수 있었기 때문에 LcGameModeBase 에서도 함수 하나를 만들어 줍니다. 
		
	bool ALcGameModeBase::IsExperienceLoaded() const
	{
		check(GameState);
		ULcExperienceManagerComponent* ExperienceManagerComponent = GameState->FindComponentByClass<ULcExperienceManagerComponent>();
		check(ExperienceManagerComponent);

		return ExperienceManagerComponent->IsExperienceLoaded();
	}

	void ALcGameModeBase::HandleStartingNewPlayer_Implementation(APlayerController* NewPlayer)
	{
		if (IsExperienceLoaded())
		{
			Super::HandleStartingNewPlayer_Implementation(NewPlayer);
		}
	}

	그리고 SpawnDefaultPawnAtTransform_Implementation 는 Pawn이 스폰된 후에 호출되는 함수인데 이때 로그를 하나 찍어보면 Pawn이 스폰되었는지를 확인 할 수 있어서 오버라이딩해봤습니다.
		
	APawn* ALcGameModeBase::SpawnDefaultPawnAtTransform_Implementation(AController* NewPlayer, const FTransform& SpawnTransform)
	{
		UE_LOG(LogLC, Log, TEXT("SpawnDefaultPawnAtTransform_Implementation is called!"));
		return Super::SpawnDefaultPawnAtTransform_Implementation(NewPlayer, SpawnTransform);
	}

	SpawnDefaultPawnAtTransform_Implementation는 HandleStartingNewPlayer_Implementation를 수정하기 전후로 테스트하기 위해서 만든 오버라이딩이었습니다. 


	HandleStartingNewPlayer_Implementation 에서 Experience가 로딩될때까지 Pawn을 스폰하지 않도록 막아 뒀는데 지금 상태의 코드로는 계속 막혀 있을것이기 때문에 
	Experience 로딩 코드를 만들어야 합니다. 

	HandleStartingNewPlayer_Implementation 을 호출한 다음은 프레임이 하나 넘어갔습니다. 그 후 순서는 HandleMatchAssignmentIfNotExpectingOne -> OneMatchAssignmentGiven -> 
	ExperienceManagerComponent->ServerSetCurrentExperience -> StartExperienceLoad -> FStreamableDelegate::CreateUObject(this, &ThisClass::OnExperienceLoadComplete)
	순으로 코드가 진행될것입니다.

	지금까지 Experience 가 로딩되면 호출하도록 델리게이트를 걸어놨는데 정작 로딩은 어디서 하는지를 안만들어 놨습니다. 
	어디서 로딩을 시작할거냐면 지금 라이라 프로젝트를 만들면서 초반에 만들었던 오버라이드 함수 HandleMatchAssignmentIfNotExpectingOne 에서 할겁니다. 

	void ALcGameModeBase::HandleMatchAssignmentIfNotExpectingOne()
	{
		// 해당 함수에서는 우리가 로딩할 Experience에 대해 PrimaryAssetId를 생성하여, OnMatchAssignmentGiven으로 넘겨준다

		FPrimaryAssetId ExperienceId;

		// precedence order (highest wins)
		// - matchmaking assignment (if present)
		// - default experience

		UWorld* World = GetWorld();

		// fall back to the default experience
		// 일단 기본 옵션으로 default하게 B_HakDefaultExperience로 설정놓자
		if (!ExperienceId.IsValid())
		{
			ExperienceId = FPrimaryAssetId(FPrimaryAssetType("LcExperienceDefinition"), FName("B_LcDefaultExperience"));
		}

		// 필자가 이해한 HandleMatchAssignmentIfNotExpectingOne과 OnMatchAssignmentGiven()은 아직 직관적으로 이름이 와닫지 않는다고 생각한다
		// - 후일, 어느정도 Lyra가 구현되면, 해당 함수의 명을 더 이해할 수 있을 것으로 예상한다
		OnMatchAssignmentGiven(ExperienceId);
	}
	코드를 보면 FPrimaryAssetId 객체 ExperienceId 를 만들고 IsValid() 가 아니라면 FPrimaryAssetId 값을 넣어줄겁니다. 이때 IsVaild 체크는 무조건 통과합니다. 왜냐면 
	객체를 만들자 마자 아무것도 안넣어 준 상태로 조건문을 걸기 때문입니다. 
	ExperienceId 에 FPrimaryAssetId를 넣을때 타입을 LcExperienceDefinition으로 넣고 이름을 B_LcDefaultExperience 로 넣었습니다. 
	B_LcDefaultExperience 는 이전에 LcExperienceDefinition 을 상속받은 블루프린트를 만들었었습니다. 
	
	ExperienceId 에 기본타입의 LcExperienceDefinition 을 넣어주고 있는겁니다. 
	그런데 이 ExperienceId = FPrimaryAssetId(FPrimaryAssetType("LcExperienceDefinition"), FName("B_LcDefaultExperience"));
	코드가 Experience 를 로딩하고 있는것은 아닙니다. 

	블루프린트 B_ExperienceList3D 에서 포탈을만들때 먼저 LcUserFacingExperience 타입의 PrimaryAssetId 들을 가져와 비동기로딩을 해서 UserFacingExperienceList 라는 리스트에 추가를 했었습니다.
	그 후에 적절한 위치에 로딩해 리스트에 담아놓은 LcUserFacingExperience 들을 포탈의 형태로 스폰했었습니다. 

	이렇듯이 위에 ExperienceId 를 FPrimaryAssetId 로 Id를 가져오는것은 스캔되어있는 Experience 들을 설정하기 위해 Id를 가져오는겁니다. 
	지금 보는 함수이름이 HandleMatchAssignmentIfNotExpectingOne 인 이유는 과제를 골라주는데 적어도 하나는 골라주도록 핸들링하는것입니다.
	본래 라이라 프로젝트에서는 이 함수에서 여러 조건에 따라 그에 맞는 ExperienceId 를 가져왔는데 지금은 그냥 가장 기본 ExperienceId를 가져오는겁니다. 
	
	그리고 이렇게 구한 ExperienceId 를 가지고 OnMatchAssignmentGiven 라는 함수를 호출합니다. 이 함수를 구현해보겠습니다.

	void ALcGameModeBase::OnMatchAssignmentGiven(FPrimaryAssetId ExperienceId)
	{
		// 해당 함수는 ExperienceManagerComponent을 활용하여 Experience을 로딩하기 위해, ExperienceManagerComponent의 ServerSetCurrentExperience를 호출한다

		check(ExperienceId.IsValid());

		ULcExperienceManagerComponent* ExperienceManagerComponent = GameState->FindComponentByClass<ULcExperienceManagerComponent>();
		check(ExperienceManagerComponent);
		ExperienceManagerComponent->ServerSetCurrentExperience(ExperienceId);
	}
	코드를 읽어보면 일단 인자로 받은 ExperienceId 가 유효한지 체크 후 LcExperienceManagerComponent 를 가져오고 체크. 그리고 가져온 ExperienceManagerComponent의 멤버 함수 
	ServerSetCurrentExperience(ExperienceId) 를 호출합니다. 
	
	이 ServerSetCurrentExperience 를 보겠습니다. 라이라 프로젝트는 원래 데디케이트 서버기반으로 동작합니다. 서버 클라이언트간 통신에서는 서로 패킷을 만들어 주고 받으면서 네트워킹을 하는데 
	원래 GameMode 라는것은 클라이언트가 아니라 서버쪽에 위치합니다. 그리고 이 GameMode 에서 지금 이 ExperienceLoad 를 진행하고 있었습니다. 그래서 함수이름에 Server 가 들어가는겁니다. 

	그리고 직접적인 Experience 로딩을 GameMode 에서 직접 하는게 아니라 ExperienceManagerComponent 로 넘겨주고 있습니다. 

	void ULcExperienceManagerComponent::ServerSetCurrentExperience(FPrimaryAssetId ExperienceId)
	{
		ULcAssetManager& AssetManager = ULcAssetManager::Get();

		TSubclassOf<ULcExperienceDefinition> AssetClass;
		{
			FSoftObjectPath AssetPath = AssetManager.GetPrimaryAssetPath(ExperienceId);
			AssetClass = Cast<UClass>(AssetPath.TryLoad());
		}

		// 왜 CDO를 가져오는 걸까?
		const ULcExperienceDefinition* Experience = GetDefault<ULcExperienceDefinition>(AssetClass);
		check(Experience != nullptr);
		check(CurrentExperience == nullptr);
		{
			// 그리고 CDO로 CurrentExperience를 설정한다!
			// 어떤 의도로 이렇게 코드를 작성한지는 코드를 쭉 읽어보고(StartExperienceLoad까지 읽어보자) 다시 생각해보자:
			CurrentExperience = Experience;
		}

		StartExperienceLoad();
	}
	이 함수에서는 먼저 오버라이딩으로 만든 LcAssetManager 를 가져옵니다.
	AssetClass 를 만들었는데 TSubclassOf 란 템플릿으로 넘겨준 타입의 클래스를 상속받은 하위 클래스만 담을 수 있는 객체였습니다. 
	그래서 그 아래 대괄호에서 ExperienceId 의 경로를 가져오고 그 경로를 TryLoad() 함수로 동기화 식으로 로딩을 하고 있습니다. 
	
	결론적으로는 ExperienceId 라고 하는 이 FPrimaryAssetId 는 LcGameModeBase::InitGame 에서 다음 프레임에 실행되도록 호출했던 
	LcGameModeBase::HandleMatchAssignmentIfNotExpectingOne 함수로부터 LcExperienceDefinition 타입의 B_LcDefaultExperience 라는 이름의 기본 LcExperienceDefinition 의 아이디를 
	ExperienceId 라는 변수로 받아서 LcGameModeBase::OnMatchAssignmentGiven 을 통해 호출된 LcExperienceManagerComponent::ServerSetCurrentExperience 까지 넘어온 아이디를 
	TryLoad 로 비동기 로딩을 실행한것입니다. 
	로딩이 끝난후에 AssetClass 변수에 저장을 합니다. 

	다음 코드에서 AssetClass 를 GetDefault 함수에 인자로 넣고 호출합니다. 이 GetDefault 함수는 CDO(Class Default Object)형식으로 가져오는함수입니다. 
	가져온 CDO 를 const ULcExperienceDefinition* Experience 라는 변수에 저장을 하고 체크를 한번하고 CurrentExperience 에 저장합니다. 

	이러면 B_LcDefaultExperience 가 로딩이 됐고 LcExperienceManagerComponent 의 CurrentExperience 에 저장도 되었는데 마지막 줄에 이어서 
	StartExperienceLoad(); 함수가 호출됩니다. 

	로딩을 진행했는데 왜 또 로딩을 할까요?

	일단 구현을 해보겠습니다. 
	이번에 추가할 함수의 시그니처만 먼저 보면 
	void StartExperienceLoad();
	void OnExperienceLoadComplete();
	void OnExperienceFullLoadCompleted();
	이렇게 3가지 함수를 추가할겁니다. 
	이 시점에 LcExperienceManagerComponent.cpp 상단에 헤더하나를 추가해줘야합니다. 

	#include "GameFeaturesSubsystemSettings.h"

	먼저 StartExperienceLoad 입니다. 
	void ULcExperienceManagerComponent::StartExperienceLoad()
	{
		check(CurrentExperience);
		check(LoadState == ELcExperienceLoadState::Unloaded);

		LoadState = ELcExperienceLoadState::Loading;

		ULcAssetManager& AssetManager = ULcAssetManager::Get();

		// 이미 앞서, ServerSetCurrentExperience에서 우리는 ExperienceId를 넘겨주었는데, 여기서 CDO를 활용하여, GetPrimaryAssetId를 로딩할 대상으로 넣는다!
		// - 왜 이렇게 하는걸까?
		// - GetPrimaryAssetId를 좀 더 자세히보자:
		// - GetPrimaryAssetId를 살펴봄으로써, 아래의 두가지를 알 수 있다:
		//   1. 우리는 B_LcDefaultExperience를 BP로 만든 이유
		//   2. CDO를 가져와서, GetPrimaryAssetId를 호출한 이유

		// 우리는 앞서 이미 CDO로 로딩하여, CDO를 사용하지 않고 CDO를 사용하여 로딩할 에셋을 지정하여, BundleAssetList에 추가해준다!

		TSet<FPrimaryAssetId> BundleAssetList;
		BundleAssetList.Add(CurrentExperience->GetPrimaryAssetId());

		// load assets associated with the experience
		// 아래는 우리가 후일 GameFeature를 사용하여, Experience에 바인딩된 GameFeature Plugin을 로딩할 Bundle 이름을 추가한다:
		// - Bundle이라는게 후일 우리가 로딩할 에셋의 카테고리 이름이라고 생각하면 된다 (일단 지금은 넘어가자 후일, 또 다룰 것이다!)
		TArray<FName> BundlesToLoad;
		{
			// 여기서 주목해야 할 부분은 OwnerNetMode가 NM_Standalone이면? Client/Server 둘다 로딩에 추가된다!
			const ENetMode OwnerNetMode = GetOwner()->GetNetMode();
			bool bLoadClient = GIsEditor || (OwnerNetMode != NM_DedicatedServer);
			bool bLoadServer = GIsEditor || (OwnerNetMode != NM_Client);
			if (bLoadClient)
			{
				BundlesToLoad.Add(UGameFeaturesSubsystemSettings::LoadStateClient);
			}
			if (bLoadServer)
			{
				BundlesToLoad.Add(UGameFeaturesSubsystemSettings::LoadStateServer);
			}
		}

		FStreamableDelegate OnAssetsLoadedDelegate = FStreamableDelegate::CreateUObject(this, &ThisClass::OnExperienceLoadComplete);

		// 아래도, 후일 Bundle을 우리가 GameFeature에 연동하면서 더 깊게 알아보기로 하고, 지금은 앞서 B_LcDefaultExperience를 로딩해주는 함수로 생각하자
		TSharedPtr<FStreamableHandle> Handle = AssetManager.ChangeBundleStateForPrimaryAssets(
			BundleAssetList.Array(),
			BundlesToLoad,
			{}, false, FStreamableDelegate(), FStreamableManager::AsyncLoadHighPriority);

		if (!Handle.IsValid() || Handle->HasLoadCompleted())
		{
			// 로딩이 완료되었으면, ExecuteDelegate를 통해 OnAssetsLoadedDelegate를 호출하자:
			// - 아래의 함수를 확인해보자:
			FStreamableHandle::ExecuteDelegate(OnAssetsLoadedDelegate);
		}
		else
		{
			Handle->BindCompleteDelegate(OnAssetsLoadedDelegate);
			Handle->BindCancelDelegate(FStreamableDelegate::CreateLambda([OnAssetsLoadedDelegate]()
				{
					OnAssetsLoadedDelegate.ExecuteIfBound();
				}));
		}

		// FrameNumber를 주목해서 보자
		static int32 StartExperienceLoad_FrameNumber = GFrameNumber;
	}
	코드 위에서부터 읽어보자면 일단 CurrentExperience가 유효한지, 지금 ELcExperienceLoadState가 Unloaded 인지를 체크합니다. 
	이 체크를 통과했다면 먼저 LoadState를 Loading 으로 변경합니다. 

	다음으로 BundleAssetList 라는 TSet에 CurrentExperience->GetPrimaryAssetId 를 넣어주고 있습니다. 
	BundleAssetList 가 TSet<FPrimaryAssetId> 타입의 컨테이너였는데 이 FPrimaryAssetId는 위에서 LcGameModeBase::HandleMatchAssignmentIfNotExpectingOne 에서 
	직접 하드코딩으로 B_LcDefaultExperience 의 아이디를 가져왔었습니다. 
	이것을 하드코딩이 아니라 GetPrimaryAssetId() 함수로 가져올 수 있습니다. 

	이후로 다시 TArray<FName> BundleToLoad 라는 배열이 있고

	const ENetMode OwnerNetMode = GetOwner()->GetNetMode();
	bool bLoadClient = GIsEditor || (OwnerNetMode != NM_DedicatedServer);
	bool bLoadServer = GIsEditor || (OwnerNetMode != NM_Client);

	OwnerNetMode를 통해 bLoadClient, bLoadServer 라는 불리언 값 두개를 가져옵니다. 각각 GIsEditor 부분은 에디터 모드에서 실행중인지의 불리언값인데 무시하고 진행해도 됩니다.
	OwnerNetMode 가 NM_DedicatedServer 가 아니면 클라이언트인것이고 맞다면 서버인것이라는 겁니다. 
	이 두 불리언 값으로 조건문을 걸어서 BundleToLoad 에 값을 채웁니다. OwnerNetMode 가 클라이언트라면 UGameFeaturesSubsystemSettings::LoadStateClient, 서버라면 
	UGameFeaturesSubsystemSettings::LoadStateServer 라고 Add 를 하고 있습니다. 
	이게 무슨 값이냐면 사실 
	LoadStateClient 는 TEXT("Client");
	LoadStateServer 는 TEXT("Server");
	입니다. 
	즉, BundleToLoad 에 Client, Server 라는 FName 이 들어간겁니다. 

	다음은 델리게이트를 걸어줍니다. 

	FStreamableDelegate OnAssetsLoadedDelegate = FStreamableDelegate::CreateUObject(this, &ThisClass::OnExperienceLoadComplete);
	OnExperienceLoadComplete 라는 함수를 델리게이트로 거는데 명칭을보면 Experience가 로드가 완료된 후 발생되는 함수같습니다. 

	왜 이 함수를 델리게이트 걸어야하는지는 이 밑 코드 부터 보고 오겠습니다.
	밑의 코드는 AssetManager::ChangeBundleStateForPrimaryAssets 라는 함수를 호출하고 있습니다. 이 함수가 하는일은 주어진 Asset 목록에 대해 번들 상태를 변경하고, 필요에 따라 
	Asset을 비동기적으로 로딩하고, 로드가 완료되면 인자로 준 델리게이트 함수를 호출합니다. 
	이때 첫번째 인자로 TArray<FPrimaryAssetId> 를 받고 있어서 위의 BundleAssetList를 만들고 BundleAssetList.Array() 로 변환해 인자로 넣어주고 있습니다. 

	분명 ServerSetCurrentExperience 에서 B_LcDefaultExperience의 경로로 TryLoad를 했는데 여기서 왜 다시 로드하냐면 
	라이라는 많은 에셋을 관리할 수 있는 시스템입니다. 
	이때 BundleToLoad 가 뭔지 이해를 해야하는데 지금 코드에서는 그냥 Client, Server 라는 문자열만 가지고 있을 수 있는데 
	만약 어떤 LcExperienceDefinition 이 가지고 있는 데이터가 많다고 해보겠습니다. 직업 데이터들을 가지고 있어서 전사,법사,궁수 등등의 데이터를 가지고 있는데 
	이중에 전사 라는 카테고리의 데이터만 로딩하고 싶은겁니다. 전사 관련 데이터만 필요한데 모든 직업의 데이터를 다 로딩하는건 비효율적이기 때문인데 
	이럴때 사용하는게 ChangeBundleStateForPrimaryAssets 함수입니다. 

	ChangeBundleStateForPrimaryAssets 으로 전사와 관련된 데이터를 로딩하고 싶다면 BundleAssetList 에 직업에 대한 LcExperienceDefinition 의 PrimaryAssetId 를 넣고 
	BundleToLoad 에는 "전사" 라는 FName을 넣는겁니다. 그리고 ChangeBundleStateForPrimaryAssets 의 두번째 인자로 넣습니다. 
	그러면 ChangeBundleStateForPrimaryAssets 함수 내부에서 BundleToLoad 로 넘겨준 번들네임과 같은 것을 찾아 ExistingHandle.Add 로 무언가 진행합니다. 

	즉, BundleAssetList 이라는 LcExperienceDefinition에서 BundleToLoad 와 관련된 데이터만 로딩하는게 ChangeBundleStateForPrimaryAssets 라는겁니다. 
	그런데 이전에 LcExperienceDefinition 에서 들고 있는 데이터인 DefaultPawnData, GameFeaturesToEnable 은 번들을 지정하지 않았었습니다. 나중에 이 번들을 지정해줄건데 
	만약 전사라는 번들을 로드하고 싶다고 인자를 넣으면 현재 B_LcDefaultExperience 에서는 그에 해당하는 데이터가 없는겁니다. 

	지금 우리코드로는 이제 Server 혹은 Client 라는 번들을 가진 데이터를 모두 로드하게될겁니다.
	라이라 프로젝트의 경우 데디케이트 서버 방식으로 되어있기때문에 클라이언트에서만 로드 필요한게 있을수 있고 서버쪽 에서만 필요한게 나눠져 있을건데 그걸 대비한 코드가 지금 코드입니다. 
	
	그런데 ChangeBundleStateForPrimaryAssets 는 이 로딩이 비동기 로딩이라고 했는데 그래서 이어서 핸들을 가지고 조건문을 걸어 
	지금 로드가 완료되었는지를 체크하고 있습니다. 로드가 바로 완료되었다면 OnExperienceLoadComplete 를 델리게이트로 만들어 놨던걸 ExecuteDelegate를 호출하고 
	만약 비동기로딩이 아직 완료 되어 있지 않다면 BindCompleteDelegate 를 걸고 만약에 ChangeBundleStateForPrimaryAssets 의 비동기 호출이 실패했더라도 델리게이트를 걸어줍니다. 

	여기서 델리게이트를거는 OnExperienceLoadComplete 는 하는일이 굳이 OnExperienceFullLoadCompleted를 다시 호출해주고 있습니다. 
	왜이러냐면 지금 만드는 프로젝트가 라이라의 아주 초창기 버전이기 때문에 로딩할게 많이 없는데 원본같은경우는 여기서 많은 것들을 로드하고 FullLoad 로 넘겨줍니다. 

	OnExperienceFullLoadCompleted 에서 하는 일은 LoadState를 Loaded로 설정하고 OnExperienceLoaded.Broadcast를 해줍니다. 
	OnExperienceLoaded 가 뭐였냐면 LcExperienceDefinition 를 델리게이트로 만든것이었습니다. 이 델리게이트가 걸린게 어디였냐면 
	LcGameModeBase::InitGameState 에서 GameState 가 로드되면 CallOrRegister_OnExperienceLoaded 로 OnExperienceLoaded를 호출하도록 걸었고 
	또 LcPlayerState::PostInitializeComponents 에서 PlayerState가 로딩된 후 CallOrRegister_OnExperienceLoaded 로 OnExperienceLoaded를 호출하도록 했었습니다.  

	
	마지막으로 지금까지 했던 Experience Load 진행을 한번 쭉 따라가면서 복기 해보겠습니다. 
	처음 시작점은 LcGameModeBase::InitGame 입니다. 여기서 다음프레임에 HandleMatchAssignmentIfNotExpectingOne 를 실행하도록 요청을 합니다. 
	다음프레임에 실행된 HandleMatchAssignmentIfNotExpectingOne 에서는 LcExperienceDefinition 타입의 B_LcDefaultExperience 의 PrimaryAssetId를 가져옵니다.
	이걸 OnMatchAssignmentGiven으로 인자로 주고 여기서 LcExperienceManagerComponent::ServerSetCurrentExperience 쪽으로 넘겨줍니다. 
	ServerSetCurrentExperience 에서는 AssetManager를 가져와 ExperienceId 가 스캔된다면 그 경로를 가져와 TryLoad로 동기화 로딩을 합니다. 
	B_LcDefaultExperience 블루프린트가 로딩이 되는건데 로딩후 GetDefault 함수를 통해 CDO를 가져와 이 상태에서 CurrentExperience 로 들고 있게 됩니다.
	이어서 StartExperienceLoad를 진행합니다. 여기서는 BundleAssetList 와 BundleToLoad 를 통해 원하는 특정 번들을 로드하도록 요청을 합니다. 
	이로딩이 전부 완료되었으면 OnExperienceLoadComplete 를 호출후 이어서 OnExperienceFullLoadCompleted 를 호출 여기서 OnExperienceLoaded의 Broadcast를 해주게 됩니다. 

	여기서 아직 해결되지 않은 부분이 있는데 왜 ExperienceId를 가져올때 블루프린트인 B_LcDefaultExperience 를 만들어 사용했는지와 CurrentExperience 를 로드된 Experience의 CDO를
	가져왔는지 입니다. 


	로딩이 되었고 그동안 막아뒀던 PawnData 부분을 진행하겠습니다. 
	먼저 LcPlayerState 코드를 보겠습니다 여기서는 PawnData 를 가지고 있으면서 캐싱을 하는게 주 목적입니다. 
	캐싱을 한 데이터를 꺼내고 설정하는 GetPawnData, SetPawnData 두가지 함수는 있어야할것이고 그리고 LcPlayerState::PostInitializeComponents 에서 델리게이트 걸어주는 
	LcPlayerState::OnExperienceLoaded 의 내용도 채워줘야겠습니다. 
	
	void ALcPlayerState::OnExperienceLoaded(const ULcExperienceDefinition* CurrentExperience)
	{
		if (ALcGameModeBase* GameMode = GetWorld()->GetAuthGameMode<ALcGameModeBase>())
		{
			// AHakGameMode에서 GetPawnDataForController를 구현해야 함
			// - GetPawnDataForController에서 우리는 아직 PawnData를 설정하지 않았으므로, ExperienceMangerComponent의 DefaultPawnData로 설정한다
			const ULcPawnData* NewPawnData = GameMode->GetPawnDataForController(GetOwningController());
			check(NewPawnData);

			SetPawnData(NewPawnData);
		}
	}
	LcPlayerState 의 OnExperienceLoaded는 멤버함수 PostInitializeComponents 에서 LcExperienceDefinition 의 CallOrRegister_OnExperienceLoaded 로 델리게이트가 걸어지면서 호출됩니다.
	이 함수에서는 먼저 LcGameModeBase 를 찾아오면서 시작하는데 GameMode 의 GetPawnDataForController 라는 함수를 호출하기 위해서입니다. 근데 이 GetPawnDataForController 함수는 아직 구현하지 못합니다.
	PawnData 자체를 아직 제대로 구현하지 않았기 때문에 일단 놔두겠습니다. 
	그런데 이 GetPawnDataForController 함수를 호출하고 난 반환값을 NewPawnData 라는 변수에 담아 지금 LcPlayerState 에 SetPawnData 를 하고 있습니다. 

	template <class T>
	const T* GetPawnData() const { return Cast<T>(PawnData); }
	GetPawnData 는 템플릿 문법을 쓸겁니다. 이전에 LcPlayerState 를 만들었을때 같이 만든 
	UPROPERTY()
	TObjectPtr<const ULcPawnData> PawnData;
	를 템플릿으로 받은 클래스로 캐스팅해서 반환합니다.

	void ALcPlayerState::SetPawnData(const ULcPawnData* InPawnData)
	{
		check(InPawnData);

		// PawnData가 두번 설정되는 것은 원하지 않음!
		check(!PawnData);

		PawnData = InPawnData;
	}
	인자로 받은 InPawnData 를 체크하고 다시 멤버변수 PawnData 의 Not 을 체크합니다. !PawnData 가 체크를 통과해야 비어있다는 것일겁니다. 
	그 후 데이터를 복사해 넣습니다.

	이제 GetPawnDataForController 를 LcGameModeBase 에서 구현해보겠습니다. 
	const ULcPawnData* ALcGameModeBase::GetPawnDataForController(const AController* InController) const
	{
		// 게임 도중에 PawnData가 오버라이드 되었을 경우, PawnData는 PlayerState에서 가져오게 됨
		if (InController)
		{
			if (const ALcPlayerState* HakPS = InController->GetPlayerState<ALcPlayerState>())
			{
				// GetPawnData 구현
				if (const ULcPawnData* PawnData = HakPS->GetPawnData<ULcPawnData>())
				{
					return PawnData;
				}
			}
		}

		// fall back to the default for the current experience
		// 아직 PlayerState에 PawnData가 설정되어 있지 않은 경우, ExperienceManagerComponent의 CurrentExperience로부터 가져와서 설정
		check(GameState);
		ULcExperienceManagerComponent* ExperienceManagerComponent = GameState->FindComponentByClass<ULcExperienceManagerComponent>();
		check(ExperienceManagerComponent);

		if (ExperienceManagerComponent->IsExperienceLoaded())
		{
			// GetExperienceChecked 구현
			const ULcExperienceDefinition* Experience = ExperienceManagerComponent->GetCurrentExperienceChecked();
			if (Experience->DefaultPawnData)
			{
				return Experience->DefaultPawnData;
			}
		}

		// 어떠한 케이스에도 핸들링 안되었으면 nullptr
		return nullptr;
	}
	이 함수의 처음에 하는게 PlayerState를 가져와서 또 GetPawnData 를 해서 이게 존재하면 그걸 그대로 반환한다고 합니다. 
	분명 이 GetPawnDataForController 는 LcPlayerState 에서 호출됐었는데 곧바로 다시 호출하는게 무슨짓인가 싶은데 
	그런데 이 시점에서 PlayerState에는 아직 PawnData가 아직 캐싱이 안되어있다보니 이 코드는 통과가 되서 그냥 넘어가게 됩니다. 

	다음 코드로 가면 LcExperienceManagerComponent를 가져와서 로딩이 완료되어있다면 LcExperienceManagerComponent::GetCurrentExperienceChecked 라는 함수를 호출합니다.
	그리고 DefaultPawnData를 가져옵니다. 

	GetCurrentExperienceChecked 함수가 뭐하는 함수냐면 
	const ULcExperienceDefinition* ULcExperienceManagerComponent::GetCurrentExperienceChecked() const
	{
		check(LoadState == ELcExperienceLoadState::Loaded);
		check(CurrentExperience != nullptr);
		return CurrentExperience;
	}
	LoadState가 Loaded 상태인지와 CurrentExperience 가 nullptr 이 아닌지를 체크한 후 CurrentExperience 를 반환하는 함수였습니다. 

	다시 GetPawnDataForController 함수에 대해 생각해보겠습니다. 이 함수가 PlayerState 에서 호출됐음에도 다시 PlayerState로 가서 PawnData를 가져오려고 하는지는
	두가지 이유가 있습니다. 
	첫번째로는 안전성 검사입니다. PlayerState::OnExperienceLoaded 함수는 Loaded 상태에서 호출된다는걸 혹시 모르니 한번더 체크를 해보는겁니다. 
	GetCurrentExperienceChecked 함수를 통함으로써
	두번째로는 PawnData 를 가져오는 걸 하나의 함수로 통일하기 위해서입니다. 
	지금 코드에서야 PlayerState 만 구현했으니 여기서만 쓰는것 같지만 좀 있다가는 GameMode 에서도 사용할거니 중간인 ExperienceManager 가 PawnData를 가져오는 역할을 맡는겁니다. 
	
	그리고 만약 게임도중에 PawnData가 수정이 되었다면 PlayerState 에서 PawnData를 가져와야합니다. 라이라 프로젝트에서는 내부적으로 PawnData 를 수정하면 PlayerState만 수정을 
	해주는데 이런경우때문에 이런 코드가 있습니다. 

	이어서 GameMode 코드로 가겠습니다.
	LcGameModeBase::OnExperienceLoaded 를 봐야할것입니다. PlayerState 도 같은 부분을 봤었으니깐 
	void ALcGameModeBase::OnExperienceLoaded(const ULcExperienceDefinition* CurrentExperience)
	{
		// PlayerController를 순회하며
		for (FConstPlayerControllerIterator Iterator = GetWorld()->GetPlayerControllerIterator(); Iterator; ++Iterator)
		{
			APlayerController* PC = Cast<APlayerController>(*Iterator);

			// PlayerController가 Pawn을 Possess하지 않았다면, RestartPlayer를 통해 Pawn을 다시 Spawn한다
			// - 한번 OnPossess를 보도록 하자:
			if (PC && PC->GetPawn() == nullptr)
			{
				if (PlayerCanRestart(PC))
				{
					RestartPlayer(PC);
				}
			}
		}
	}
	월드를 가져오고 다시 PlayerController의 이터레이터를 가져와 전부 순회를 해주고 있습니다. 
	순회하면서 각 컨트롤러가 Pawn을 가지고 있는지를 체크해서 없다면 PlayerCanRestart, RestartPlayer 를 호출해주고 있습니다. 
	플레이어 컨트롤러를 순회하는 이유는 플레이어나 폰이 생성되긴 했는데 그 데이터가 로딩되기 전에 생성되면 아무것도 못하는 상황이 있는데 
	Experience 가 로딩이 완료되면 데이터들도 로딩이 된것이기 때문에 지금 이 OnExperienceLoaded 에서 한번 순회해주며 초기화를 다시 해주는것입니다. 
	
	초기화를 해줄때 RestartPlayer 를 해주는데 단순히 플레이어를 재시작해주는게 아니라 
	내부적으로 FindPlayerStart 라는 함수를 통해 플레이어의 스타트 지점을 찾아줍니다. 다시 ReStartPlayerAtPlayerStart 함수를 따라 들어가보면 GetPawn을 하는데 
	처음 호출될때는 없을것이기 때문에 GetDefaultPawnClassForController 함수를 통해 컨트롤러로 부터 디폴트 폰을 가져옵니다. 그리고 그 폰을 스폰합니다.
	폰을 스폰한 후에는 Controller의 SetPawn을 진행합니다. 그 후에는 FinishRestartPlayer 를 통해 스폰한 폰에 Possess 까지 진행이 됩니다. 

	그런데 이 RestartPlayer 함수의 로직은 라이라 프로젝트를 만들면서 따라온 로직과 비슷합니다. 
	GameInstance, World, Level, GameMode, GameState, ExperienceManagerComponent, Character, PlayerController, PlayerState 순으로 클래스들이 만들어지면서 
	내부적으로 멤버 함수들이 호출됐었는데 이 중에서 SpawnPlayActor 를 통해 폰들을 스폰하면서 폰들의 스폰과 초기화를 해주는 로직이 위와 비슷한 흐름이었습니다. 

	즉, LcGameModeBase::RestartPlayer 는 위의 로직을 다시 실행하는것입니다. 
	폰을 스폰하기전에 Experience 부터 로딩이 되야 하니까 HandleStartingNewPlayer_Implementation 에서 스폰 코드 진행을 막아 놨습니다. 
	그 막아놓은것을 OnExperienceLoaded 에서 확실히 로딩이 된후 그동안 스폰을 막아 뒀던 폰들에게 RestartPlayer 를 호출해주는것입니다. 

	RestartPlayer 를 호출한 후에는 코드를 진행하다 보면 다시 HandleStartingNewPlayer_Implementation 에 다시 오게 될겁니다. 
	이 시점에서는 막아뒀던 조건인 IsExperienceLoaded 가 통과가 될겁니다. 

	여기까지 하고 한번 빌드도 하고 테스트 실행을 해보면 
	ULcExperienceManagerComponent::ServerSetCurrentExperience 함수내에서 CDO를 만드는 부분에서 에러가 뜹니다. 
	AssetClass 가 nullptr 이라고 뜨는데 함수를 따라 올라가보면 ALcGameModeBase::OnMatchAssignmentGiven 에서 ServerSetCurrentExperience 를 호출했는데
	여기서는 받은 인지 체크하고 다시 넘겨준것 밖에 없습니다. 그러면 다시 따라 올라가보겠습니다. 
	그러면 ALcGameModeBase::HandleMatchAssignmentIfNotExpectingOne 에서 호출이 되었었습니다. 
	이 함수에서 무언가 한것은 디폴트 ExperienceId 를 생성했던 부분입니다. FPrimaryAssetType, FPrimaryAssetId 를 넣어서 ID를 가져오는 코드였는데 
	그러면 혹시 넘겨준 타입과 아이디가 스캔에 안걸려서 그런가 싶은데 언리얼에디터로 살펴보면 사실은 블루프린트 이름이 잘못 입력된 오타였습니다. 
	라이라 프로젝트를 똑같이 따라하다 보니 블루프린트 이름에 B_LcDefaultExperience 가 아닌 B_LyraDefaultExperience 로 되어있어서 블루프린트의 이름을 
	B_LcDefaultExperience 로 변경합니다. 그리고 DA_ExamplePlaylist 에도 B_LcDefaultExperience 로 설정을 다시 해야합니다. 
	하드코딩으로 인한 에러였던겁니다. 

	이제 게임은 실행되지만 ALcGameModeBase::HandleStartingNewPlayer_Implementation 에서 IsExperienceLoaded 를 통과하는지 중단점을 걸어보면 통과되지는 않습니다.
	그런데 ALcGameModeBase::OnExperienceLoaded 에는 들어가고 RestartPlayer 도 실행이 됩니다. 
	로직대로 동작하지 않는 이유가 두가지가 있는데 
	첫번째로 Development 모드에서 실행하다보면 컴파일 단계에서 일부코드가 아예 컴파일 되지 않는다거나 하는 경우도 있고 
	두번째는 게임을 실행해서 아웃라이너를 보면 LcCharacter0 가 생성되어 있습니다. 

	첫번째 문제는 이전에 LcAssetManager 에서 StartInitialLoading 구현부 위아래로 PRAGMA_DISABLE_OPTIMIZATION 매크로를 입력해놨는데 이러면 
	그 영역은 Development 일때도 컴파일이 진행이 되는 매크로였습니다.
	이 매크로를 ALcGameModeBase::HandleStartingNewPlayer_Implementation 에도 추가해줍니다. 

	그리도 두번째 문제 이번에는 Character0 이 생긴 현상입니다. 
	라이라 프로젝트를 따라 만들면서 Character 에 대해 의도했던것은 B_SimpleHeroPawn 에서 간이로 만든 스피어와 실린더 메쉬로 표현한 캐릭터가 스폰되는것인데 
	이전에 ALcGameModeBase::HandleStartingNewPlayer_Implementation 에서 IsExperienceLoaded 로 막기전과 다름없이 그냥 텅빈 Character0 가 만들어졌습니다. 

	왜 이렇냐면 라이라 프로젝트의 함수 호출절차중 RestartPlayer 후 GetDefaultPawnClassForController_Implementation 라는 함수가 있는데 
	이 함수가 뭘 하냐면 ALcGameModeBase의 생성자에서 초기화하던 DefaultPawnClass = ALcCharacter::StaticClass() 를 가져옵니다. 
	DefaultPawnClass 가 ALcCharacter 라고 박아 놔버렸습니다. 그런데 제가 가져오고 싶은 PawnClass 는 B_SimpleHeroPawn 입니다. 
	그러면 GetDefaultPawnClassForController_Implementation 를 오버라이딩해서 다시 원하는대로 수정하면 되는겁니다. 
	
	UClass* ALcGameModeBase::GetDefaultPawnClassForController_Implementation(AController* InController)
	{
		// GetPawnDataForController를 활용하여, PawnData로부터 PawnClass를 유도하자
		if (const ULcPawnData* PawnData = GetPawnDataForController(InController))
		{
			if (PawnData->PawnClass)
			{
				return PawnData->PawnClass;
			}
		}

		return Super::GetDefaultPawnClassForController_Implementation(InController);
	}
	GetPawnDataForController 를 통해 PawnData를 가져오고 있습니다. 이 GetPawnDataForController는 아까 만들었던 함수인데 여기서는 
	먼저 PlayerState 에서 PawnData를 가져와 보고 안된다면 ExperienceManagerComponent를 가져와 Experience가 로드 됐는지 확인하고 
	ExperienceDefinition 을 가져와 DefaultPawnData를 가져옵니다. 이 PawnData가 유효하다면 반환하고 아니면 기존 GetDefaultPawnClassForController_Implementation 에서 
	ADefaultPawn::StaticClass 를 반환합니다.

	PlayerState가 가지고 있는 DefaultPanwData는 ALcPlayerState::OnExperienceLoaded 에서 SetPawnData 를 설정해줍니다.

	지금까지 구현해본 라이라 프로젝트는 대략 이런 느낌입니다.
	무언가 구현해봤는데 문제가 있다면 언리얼엔진에 그 기능을 담당하던부분을 오버라이딩으로 수정하자라는 개념입니다. 

	Experience Loading 에 대한 총정리
	1. ALcGameModeBase::InitGame 에서 다음프레임에 HandleMatchAssignmentIfNotExpectingOne 을 호출하도록 합니다. 
	2. ALcGameModeBase::InitGameState 에서 로딩이 완료되면 ALcGameModeBase::OnExperienceLoaded 를 호출하도록 델리게이트를 겁니다. 
	3. 다음 프레임이 되어서 HandleMatchAssignmentIfNotExpectingOne 가 호출되면 여기서 하는 일은 일단 가장 기본 ExperienceDefinition을 B_LcDefaultExperience라고 설정하고 
	OnMatchAssignmentGiven 에 그 ExperienceId를 넘겨주면서 호출합니다. 
	4. OnMatchAssignmentGiven 에서는 ExperienceManagerComponent::ServerSetCurrentExperience 로 넘겨줍니다. 
	5. ExperienceManagerComponent::ServerSetCurrentExperience 에서는 ExperienceId 에서 경로를 가져오고 TryLoad 로 동기화 로딩을 한번 한 후 CurrentExperience 로 설정합니다.
	그리고 StartExperienceLoad 를 호출합니다. 
	6. StartExperienceLoad 는 Experience를 CDO로 만들어서 Bundle로 골라서 부분 로딩을 하는 ChangeBundleStateForPrimaryAssets 를 통해 또 한번 로딩을 합니다.
	이 함수 내에서 OnExperienceLoadComplete 를 걸어놨었습니다.
	7. OnExperienceLoadComplete 에서는 OnExperienceFullLoadCompleted 를 호출하고 여기서는 CurrentExperience를 BroadCast 를 합니다. 
	이 BroadCast(CurrentExperience) 를 하면 델리게이트를 걸어 놨던 OnExperienceLoaded 가 호출이 될겁니다.
	8. 그런데 이때 OnExperienceLoaded 는 LcGameModeBase 뿐만 아니라 LcPlayerState 에서도 델리게이트를 걸어 놨어서 각자 동작할겁니다. 
	9. LcPlayerState::OnExperienceLoaded는 PawnData를 캐싱하는 함수였습니다.
	10. LcGameModeBase::OnExperienceLoaded 는 좀 더 중요한 RestartPlayer 를 호출합니다. 
	11. RestartPlayer가 호출되면 Experience 가 로드 될때 까지 막아뒀던 ALcGameModeBase::HandleStartingNewPlayer_Implementation 이 통과될겁니다. 
	12. HandleStartingNewPlayer_Implementation 가 호출되면 쭉 로직이 진행되다 ALcGameModeBase::GetDefaultPawnClassForController_Implementation 로 들어오게 됩니다.
	13. GetDefaultPawnClassForController_Implementation 에서는 ALcPlayerState 로부터 PawnData를 가져오는 GetDefaultPawnClassForController 를 호출해 반환합니다.
	14. 그 결과 만들어놨던 블루프린트 캐릭터가 스폰됩니다. 

	마지막으로 PlayerStart 를 배치해놓으면 그 위치에서 DefaultPlayer가 스폰되는데 그것만 배치하겠습니다. 
}