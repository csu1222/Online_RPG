Lyra 는 에픽게임즈에서 공식으로 배포하는 게임 프로젝트로 실제 현업수준의 거대한 프로젝트입니다. 
이 프로젝트는 언리얼 업데이트마다 그에 맞춰 업데이트되는 사실상 에픽게임즈에서 게임 제작 가이드라인의 역할을 하고 있고 
실제로 이 Lyra를 참조해 만든 게임들이 많다고 합니다. 

하지만 그만큼 내용이 방대하기 때문에 혼자 Lyra를 분석하기는 어렵습니다. 그래서 필요한 부분을 살펴보고 가져올 수 있는 방법이 있다면 가져와 사용하겠습니다. 

라이라 프로젝트는 모듈화가 잘 되어 있는 프로젝트입니다. 
이런 모듈화를 배워서 우리 프로젝트로 가져오는게 목표가 되겠습니다. 

#
에러 - 언리얼 5.5, 5.6 버전에서는 실행중 중단점이 호출되거나 빌드자체가 안되는데 5.4버전에서는 정상적으로 동작합니다. 
#

# 1 모듈 
{
	언리얼 프로젝트에서 모듈이 뭔지를 정의하자면 비쥬얼 스튜디오로 연 언리얼 프로젝트의 소스디렉토리 아래의 폴더 하나하나를 모듈이라고 할 수 있습니다. 적어도 라이라 프로젝트에서는
	그렇게 사용하고 있습니다. 그리고 프로젝트 아래의 플러그인 디렉토리와 그리고 프로젝트 파일까지 해서 
	모듈, 플러그인, 프로젝트 3가지가 언리얼 3대 요소라고 합니다. 

	이 3가지 요소의 개념을 정리하자면 
	모듈의 구성요소는 cpp 파일과 h 파일입니다. 매번 클래스를 추가하면서 생기는 파일들이었습니다. 프로젝트의 uproject 파일을 열어보면 모듈을 지웠다 작성하는걸로 프로젝트에 포함할지를
	정할 수 있습니다. 
	플러그인은 무엇이냐면 모듈들을 모은 개념입니다. 그러면 또 모듈은 cpp와 h로 이루어 져있을 겁니다. 플러그인도 마찬가지로 uproject 파일에서 Enable 값을 ture, false 를 주는걸로 
	포함 여부를 정할 수 있습니다. 

	모듈과 플러그인이 비슷해 보이는데 그 차이가 뭔지 알아보자면 에픽게임즈에서 실험적인 기능들을 플러그인으로 넣고 테스트를 합니다. 
	테스트를 하다가 이 플러그인이 안정성이 높고 유저들이 잘 사용한다 싶으면 그때 모듈로 옮기는 것입니다. 

	그럼 프로젝트가 뭐냐면 모듈과 플러그인을 모두 들고 있을 수 있는 큰 개념이고 거기에 한가지 더 컨텐츠 폴더도 들고 있을 수 있어서 에셋들도 관리합니다. 

	다시 쉽게 정리하자면 모듈은 이 프로젝트에서 안정적으로 사용할 수 있는 기능, 플러그인은 모듈들을 모아둔거지만 약간 외부에서 가져온 기능들로 안정성과 사용성이 모듈보다는 덜 
	증명된 기능 묶음, 그리고 프로젝트는 모듈, 플러그인, 에셋들을 모두 포함한 개념 이라고 할 수 있습니다. 

	새로만든 프로젝트를 보면 기본적으로 모듈이 하나 생성되어 있습니다. 
	프로젝트명.cpp, 프로젝트명.h 가 그것들인데 여기의 상단에는 IMPLEMENT_PRIMARY_GAME_MODULE 이라는 define이 있습니다. 이 define 함수는 게임모듈을 정의 하고 등록하는데 
	이때 인자로 FDefaultGameModuleImpl 을 주면 디폴트 모듈로 LC_5_4 로 등록합니다. 

	클래스를 만들면서 FDefaultGameModuleImpl 를 상속받게 되면 기본 모듈을 상속받은 나만의 커스텀 모듈을 만들 수 있습니다. 
	이때 중요한것은 지금 만든 모듈을 엔진에 사용하라고 명시를 해줘야합니다. 

	IMPLEMENT_PRIMARY_GAME_MODULE의 인자로 FDefaultGameModuleImpl 대신에 지금 새로 만든 커스텀 모듈을 넣어주는 것으로 새 커스텀 모듈을 사용하도록 명령을 한것입니다. 
	이 모듈을 만들고 사용하도록 하는 기술을 라이라에서 사용하고는 있지 않지만 일단 모듈에 대해 알기 위해서 실습을 해봅니다. 
	새 모듈의 StartModule 멤버 함수를 만들어 중단점을 걸고 실행해보면 언리얼 에디터가 완전 실행되기전에 중단점에 걸립니다. 

	주의해야할 점이 있습니다. 
	라이라 프로젝트에서 지금 배운 IMPLEMENT_PRIMARY_GAME_MODULE 부분을 확인할건데 라이라 프로젝트는 소스 폴더에서도 라이라 게임과 라이라 에디터모듈 두개로 나뉘어 있습니다. 
	그 중에 라이라 게임 모듈 cpp 파일에서 IMPLEMENT_PRIMARY_GAME_MODULE 함수를 사용하고 라이라 에디터 모듈에서는 IMPLEMENT_MODULE 로 설정하고 있습니다. 

	IMPLEMENT_PRIMARY_GAME_MODULE는 이름에서 알 수 있듯이 프로젝트에서 딱 하나만 설정할 수 있습니다. 두개의 모듈을 설정하면 실행이 되지 않습니다.
	거기에 에러가 이상하게 뜨기 때문에 문제를 알기도 힘듭니다. 
	그렇기 때문에 라이라 프로젝트처럼 라이라 게임에서 IMPLEMENT_PRIMARY_GAME_MODULE을 사용했다면 라이라 에디터에서 IMPLEMENT_MODULE를 사용해도록 해줘야합니다. 

	가장 중요한 기초 모듈에 IMPLEMENT_PRIMARY_GAME_MODULE를 하고 그 외의 모듈에서는 IMPLEMENT_MODULE를 호출해 줘야합니다. 

	LC 프로젝트에서 새로 만든 모듈에 로그를 하나 찍어서 테스트를 해봅니다. 여기까지 실습으로 모듈이 뭔지에 대한 개념 그리고 커스텀 모듈이 잘 설정되었는지를 확인할 수 있습니다. 
}


# 2 로그 
{
		앞으로 디버깅을 하면서 로그를 많이 찍어볼건데 언리얼에서 로그를 커스텀 할 수 있게 지원을 해줘서 디버깅에 필요한 로그들을 가독성 있게 볼 수 있도록 할것입니다. 
	LC 프로젝트를 실행하고 C++ 클래스를 생성하는데 None을 선택해서 아무것도 상속받지 않고 생성을 해주는데 기본생성되는 클래스는 지워주겠습니다. 

	헤더 파일에 두가지 헤더를 추가해주는데 Containers/UnrealSting.h 와 Logging/LogMacros.h 입니다. 
	그리고 나서 
	DECLARE_LOG_CATEGORY_EXTERN(LogLC, Log, All);
	이런 매크로를 사용해주게 되면 LogLC 라는 새 로그 카테고리를 만들게 되는겁니다. 그런데 헤드에만 선언하면 안되고 
	cpp 파일에서 다시 
	DEFINE_LOG_CATEGORY(LogLC);
	이렇게 정의 해줘야합니다.

	새로 만든 로그 카테고리를 어떻게 사용하냐면 이전에 로그를 찍을때 LogTemp 를 사용했던 부분을 LogLC 로 바꿔주면 이 카테고리의 로그로 출력이 됩니다. 
	앞으로 로그를 찍을때 카테고리로 나눠서 사용하게 되면 출력 로그에서 검색해 확인 하기 편해집니다. 
}


# 3 에셋 매니저
{
	에셋이란 모델링이나 사운드파일 같이 프로그래밍 외의 직군쪽에서 만든 리소스들을 말합니다. 
	이런 에셋을 매니징하는 에셋 매니저를 프로젝트에 추가할겁니다. 왜 에셋매니저를 사용하냐면 이것을 사용하기 전에는 직접 에셋을 임포트하고 수정하고 싶은 옵션을 가져와서 
	수정을 하게되는데 이동작들이 하드코딩적입니다. 에셋의 바꾸고 싶은 옵션의 경로가 바꾼다고 하면 이 에셋을 수정한 모든곳을 수정해야합니다.

	그래서 에셋매니저를 사용하게 되는데 에셋매니저를 따라 들어가 설명을 보면 싱글톤으로 PrimaryAsset 을 로딩이나 언로딩을 한다고 합니다. 프라이머리 에셋이 뭔지는 뭐르겠지만
	일단 넘어갑니다. 

	싱글톤은 프로젝트내에서 유일성을 보장해야하는 패턴입니다.
	에셋매니저에서 Get 이라는 함수를 사용할텐데 여기서 GEngine 에서 에셋 매니저를 가져와 ULcAssetManager 라는 제가 사용할 에셋매니저 타입으로 캐스팅해서 리턴을 할겁니다. 
	GEngine 이라는 글로벌로 사용하는 엔진 객체를 사용하면 이 에셋 매니저를 Get으로 가져올때마다 새로 생성하는게 아닌겁니다. 

	ShouldLogAssetLoads 라는 static 멤버 함수를 하나 추가할겁니다. 이 함수는 새로운 기법하나를 소개하는 용도인데 
	커맨드 프롬프트에서 LogAssetLoads 라는 문자를 포함하고 있는지를 불리언으로 반환하는 함수입니다. 

	bool ULcAssetManager::ShouldLogAssetLoads()
	{
		const TCHAR* CommandLineContent = FCommandLine::Get();
		static bool bLogAssetLoads = FParse::Param(CommandLineContent, TEXT("LogAssetLoads"));
		return bLogAssetLoads;
	}

	커맨드 라인에서 LogAssetLoads 라는 문자열이 있는지를 찾는다고 했는데 언리얼엔진을 실행하는데 왠 커맨드라인 인가 싶을수 있습니다. 
	그런데 프로젝트의 속성 - 디버그 - 명령 인수 를 보면 프로젝트의 uproject 을 실행하면서 뒤에 -skipcompile 이라는 인자를 같이 주고 있습니다. 여기에 추가로 
	-LogAssetLoads를 추가하게되면 위의 ShouldLogAssetLoads 함수가 true 로 반환되는겁니다. 
	이 함수를 통해 FCommandLine 이라는 함수에서 인자를 가져와 활용할 수 있다를 보여주고 언리얼에서도 커맨드라인 인자를 넣을 수 있다는것도 알 수 있었습니다. 

	SynchronousLoadAsset 이라는 멤버 함수를 하나 더 추가하겠습니다. 
	함수 명칭에서 알 수 있듯이 동기화 적으로 에셋을 로드한다는 뜻입니다. 
	다시 동기와 비동기에 대해 집고 넘어가자면 동기식 함수는 A,B라는 함수가 있고 둘 다 호출을 해야할때 A함수의 모든 로직을 실행한 후 B의 로직을 실행하기 시작하는 방식이고
	비동기는 A함수를 실행하는 중에도 B함수를 쓰레드를 할당하거나 하는 방법들로 같이 실행해 A의 로직이 끝나는것과 상관없이 B를 실행하는 것입니다. 

	보통 온라인 게임 로직에서는 비동기 방식을 선호하게 되는데 당연히 동시다발적으로 여러 동작이 일어날텐데 동기방식으로 처리하면 게임 경험이 많이 불쾌해질것입니다. 
	하지만 무조건 비동기 방식을 채택하는건 아닙니다. 

	동기 방식의 장점은 일단 비동기 방식보다 속도가 빠르고 그리고 로직 진행 순서도를 확인하기 쉽습니다. 
	그래서 동기 방식을 어디서 많이 쓰냐면 게임을 시작하거나 맵이 전환되거나하는 로딩 시간때 주로 사용합니다 어짜피 이 시간에는 유저가 조작하지 않기 때문에 
	속도가 중요하고 로직순서에 따른 문제를 최소화할 수 있는 동기 로딩을 사용하는것입니다. 그래서 이 함수 SynchronousLoadAsset 를 만든 이유가 
	인게임 중에 동기 로딩이 많아지면 프레임 드랍이 일어날 건데 이런 문제가 동기로딩에서 문제가 생기는지 찾기위해 만든겁니다.  

	UObject* ULcAssetManager::SynchronousLoadAsset(const FSoftObjectPath& AssetPath)
	{
		// 해당 함수를 따로 만든 이유는 'synchronous load asset이 불필요하게 하는 것이 없는지 확인하기 위함'
		if (AssetPath.IsValid())
		{
			// FScopeLogTime을 확인해보자:
			TUniquePtr<FScopeLogTime> LogTimePtr;
			if (ShouldLogAssetLoads())
			{
				// 단순히 로깅하면서, 초단위로 로깅 진행
				LogTimePtr = MakeUnique<FScopeLogTime>(*FString::Printf(TEXT("synchronous loaded assets [%s]"), *AssetPath.ToString()), nullptr, FScopeLogTime::ScopeLog_Seconds);
			}

			// 여기서 두가지 분기:
			// 1. AssetManager가 있으면, AssetManager의 StreamableManager를 통해 정적 로딩
			// 2. 아니면, FSoftObjectPath를 통해 바로 정적 로딩
			if (UAssetManager::IsValid())
			{
				return UAssetManager::GetStreamableManager().LoadSynchronous(AssetPath);
			}

			// if asset manager is not ready, use LoadObject()
			// - 슥 보면, StaticLoadObject가 보인다: 
			// - 참고로, 항상 StaticLoadObject하기 전에 StaticFindObject를 통해 확인하고 실패하면 진짜 로딩함
			return AssetPath.TryLoad();
		}

		return nullptr;
	}

	코드를 보면 FScopeLogTime 이라는 구조체를 UniquePtr로 만들어 LotTimePtr 이라고 들고 있습니다. 이 FScopeLogTime 구조체의 설명을 보면 로그시간을 초당으로 누적 전달하는 구조체입니다.
	위에서 만들어 놓은 ShouldLogAssetLoads 함수를 통해 커맨드라인에 LogAssetLoads 가 있다면 참을 반환해 조건문으로 들어오고 
	FScopeLogTime 를 위의 인자처럼 ScopeLog_Seconds 를 주게되면 초단위로 이 함수가 얼마나 걸렸는지 초단위로 알 수 있습니다. 그래서 동기성 함수를 실행하면서 얼마나 걸린지를 체크 할 수 있습니다. 
	그리고 AssetManager 가 유효하다면 StreamManager 라는걸 가져와서 동기화 로딩을 진행합니다. StreamableManager가 뭐냐면 동기로딩 비동기로딩을 관리하는 클래스입니다. 
	만약 AssetManager가 아직 생성이 안되서 없다면 인자로 받은 에셋 자체에 대해 TryLoad 를 진행합니다. 
	TryLoad도 내부적으로 로딩을 하는건 똑같습니다. 하지만 TryLoad를 따라 들어가 설명을 보면 굉장히 느리다고 합니다. 
	LoadSynchronous 와 TryLoad 둘 모두 로딩을 끝낸 데이터는 캐싱을해서 메모리에 올려두기 때문에 다시 로딩을 시도한다고 해도 캐싱해뒀던 데이터를 가져와 사용합니다.

	그래서 SynchronousLoadAsset 이란 함수는 거의 LoadSynchronous 함수를 그대로 사용하는데 동기로딩을 하는 시간을 한번 재보는 래핑을 한겁니다. 

	지금 이 함수가 정확히 뭔지 다시 비유하자면 게임에서 나중에 여러가지 에셋들 예를 들어 여러 무기들 혹은 캐릭터의 아바타등이 있을겁니다. 그런데 게임이 오래되면 각 종류마다 1000가지의 종류가 또 나눠질 수도 있습니다. 
	그런데 이것들을 항상 모든 클라이언트에서 로딩을 해놔서 메모리에 올려 놓을 수 없습니다. 이런걸 필요한 것들만 로딩하는게 지금 SynchronousLoadAsset 함수 내의 LoadSynchronous 와 TryLoad 입니다. 

	여기서 추가로 게임 로직을 쭉 진행중에 어떤 함수 A의 어느 부분에서 확 느려지는걸 발견을 했다고 하겠습니다. 
	예를들어서 1000초가 걸린다고했을때 위의 LogTimePtr 부분 코드 때문에 이 에셋을 로딩할때 1000초가 걸린다는걸 쉽게 체크할 수 있게 되는겁니다. 
	그래서 이 에셋로드를 동기화 로딩을 하면 안되겠다고 판단이 가능해 집니다. 

	SynchronousLoadAsset 함수에서 한가지 더 집고 넘어갈 부분이 파라매터인 FSoftObjectPath에 대해서인데 
	에셋들이 여러 종류가 있을 수 있습니다. 사운드, 메시, 블루프린트 같은 에셋들이 있다고 할때 위에서 말했듯이 모든 에셋들을 다 메모리에 들고 있을 수는 없습니다. 
	그래서 필요한 에셋을 로드를 해야하는데 그 필요한 에셋을 가리키는게 이 FSoftObjectPath 입니다. 에셋들이 프로젝트 디렉터리 안에서도 해당 경로가 있을겁니다. 

	언리얼 엔진에서 이 경로를 확인 할 수 있는데 언리얼 엔진을 실행시켜서 테스트용 아무 에셋을 하나 만들어 컨트롤 V 를 한 후 메모장에 붙여넣기를 해보면 
	이 에셋이 위치한 경로가 뜹니다. 이 경로를 들고 있는게 FSoftObjectPath의 역할입니다. 
	SynchronousLoadAsset 에 인자로 몇백메가바이트 혹은 그이상 갈 수도 있는 에셋자체를 주는게 아니라 그 경로를 주는겁니다. 마치 객체와 포인터를 보는것 같습니다. 

	다음은 템플릿을 활용한 함수들을 추가합니다. 

	template<typename AssetType>
	inline AssetType* ULcAssetManager::GetAsset(const TSoftObjectPtr<AssetType>& AssetPointer, bool bKeepInMemory)
	{
		AssetType* LoadedAsset = nullptr;
		const FSoftObjectPath& AssetPath = AssetPointer.ToSoftObjectPath();

		if (AssetPath.IsValid())
		{
			// 로딩이 되어있다? -> 바로 가져옴
			// 로딩이 안되어 있다 -> Null
			LoadedAsset = AssetPointer.Get();
			if (!LoadedAsset)
			{
				LoadedAsset = Cast<AssetType>(SynchronousLoadAsset(AssetPath));
				ensureAlwaysMsgf(LoadedAsset, TEXT("Failed to load asset [%s]"), *AssetPointer.ToString());
			}

			if (LoadedAsset && bKeepsInMemory)
			{
				// 여기서 AddLoadAsset은 메모리에 상주하기 위한 장치라고 생각하면 됨:
				// - 한번 등록되면 직접 내리지 않는한 Unload가 되지 않음 (== 캐싱)
				Get().AddLoadedAsset(Cast<UObject>(LoadedAsset));
			}
		}

		return LoadedAsset;
	}

	template<typename AssetType>
	inline TSubclassOf<AssetType> ULcAssetManager::GetSubclass(const TSoftClassPtr<AssetType>& AssetPointer, bool bKeepInMemory)
	{
		TSubclassOf<AssetType> LoadedSubclass;

		const FSoftObjectPath& AssetPath = AssetPointer.ToSoftObjectPath();
		if (AssetPath.IsValid())
		{
			LoadedSubclass = AssetPointer.Get();
			if (!LoadedSubclass)
			{
				LoadedSubclass = Cast<UClass>(SynchronousLoadAsset(AssetPath));
				ensureAlwaysMsgf(LoadedSubclass, TEXT("Failed to load asset class [%s]"), *AssetPointer.ToString());
			}

			if (LoadedSubclass && bKeepInMemory)
			{
				Get().AddLoadedAsset(Cast<UObject>(LoadedSubclass));
			}
		}

		return LoadedSubclass;
	}

	추가한 두가지 함수는 거의 동일한데 반환하는 타입이 AssetType* 인것과 TSubclassOf<AssetType> 인것 밖에 차이가 없습니다. 
	둘 모두 AssetPointer가 가리키는 에셋의 주소를 보고 유효한지 체크 유효하다면 SynchronousLoadAsset을 해서 로드 해오고 로드가 실패했다면 로그를 찍습니다. 
	또다른 매개변수인 이 에셋을 캐싱해둘지 불리언으로 받아 그 값에 따라 AddLoadedAsset 함수를 통해 계속 메모리에 올려둘지를 정합니다. 

	별개의 이야기로 여기 등장하는 용어들과 비슷한 용어를 한번 정리 해보겠습니다. 

	Asset : 블루프린트, 사운드, 메시 등
	Tsubclassof : 특정 클래스의 서브클래스의 타입정보 
	CDO : 클래스의 기본 인스턴스
	staticclass : 리플렉션을 가지고 있는 메타데이터 

	간단하게 이렇게 개념을 정리 할 수 있습니다. 
	그런데 여기서 staticclass 를 설명하는 말중 리플렉션이 무엇인지 좀 더 알아보겠습니다. 
	일단 C++ 자체에는 리플렉션이라는 기능이 없고 그래서 C# 을 통해 설명을 해보겠습니다. 

	리플렉션 이라는 용어의 이름을 보면 반사라는 뜻이 있는데 리플렉션은 런타임 단계에서 클래스에 대한 정보를 알 수 있게 해주는 것입니다. 
	이게 무슨 말이냐면 

	class Test
	{
		public int Num = 0;
		public string Name = "ABC";

		public void Print()
		{
			Console.WriteLine($"{Num}, {Name}");
		}
	}

	이런 클래스가 있고 

	static void Main(string[] args)
	{
		foreach (var Filed in typeof(Test).GetFields())
		{
			Console.WriteLine(Field.Name);
		}
	}

	이렇게 Test 클래스의 타입을 가지고 GetFields 라는 함수로 무언가 데이터를 가져와 출력해보려고 합니다. 

	이 프로그램을 실행해보면 Num과 Name이 한줄씩 출력됩니다. Test 객체를 만들어서 멤버변수를 가져와 본것이 아닌데 
	Test클래스가 가지고 있는 멤버 변수의 식별자를 가져와 버립니다. 
	GetFeilds 라는 함수뿐만아니라 

	foreach (var Method in typeof(Test).GetMethods())
	{
		Console.WriteLine(Method.Name);
	}

	Method를 가져오는 함수를 사용해 실행해보면 Print, GetType, ToString, Equals, GetHashCode 라는 문자열들이 출력됩니다. 

	리플렉션은 이런식으로 런타임 단계에서 클래스의 정보들을 알 수 있는 것을 말하는데 그 활용은 이렇게도 가능합니다. 

	static void Main(string[] args)
	{
		// 빈 Test 객체 생성
		Test a = new();

		// a 의 num값을 출력해보기 
		Console.WriteLine(a.Num);

		foreach (var Filed in typeof(Test).GetFileds())
		{
			// 리플렉션으로 Test에 Num이라는 이름의 변수가 있는지를 체크하고 있다면 인자로 넘겨준 객체의 Num 값을 수정
			if (Filed.Name = "Num")
				Filed.SetValue(a, 100);
		}

		// 수정되었는지 출력
		Console.WriteLine(a.Num);
	}

	C++ 자체 기능으로는 이런 리플렉션 기능이 없습니다. 
	하지만 언리얼같은 엔진에서는 리플렉션 기능이 필요합니다. 언리얼 엔진을 실행시켜서 에셋들의 Details를 살펴보면 이 에셋에서 UPROPERTY매크로를 붙힌 변수들을 
	엔진에서 UI적으로 수정할 수 있습니다. 이 기능도 리플렉션으로 데이터를 가져와 구현하는 것입니다. 

	언리얼엔진에서는 언리얼 빌드 툴, 언리얼 헤더 툴 등으로 C++ 에서도 리플렉션이 가능하도록 만들어 줬습니다. 그 흔적을 찾아보면 
	프로젝트의 Build 파일, Target 파일들이 C#으로 만들어져 있습니다. 

	코드로는 어떤 부분이냐면 UPROPERTY매크로를 붙힌 코드는 리플렉션이 필요하다고 기억을 해두는데 언리얼로 만든 헤더 파일에 기본적으로 추가 되어있는 .generated.h 파일과 
	클래스의 맨위에 자동으로 입력되어있는 GENERATED_BODY() 입니다.

	그런데 이런 리플렉션을 하는 대상인 이 클래스의 변수들의 이름이나 함수들의 이름을 C++의 기본 클래스인 class 가 가지고 있는게 아니라 위에서 알아본 staticclass 가 가지고 있고
	언리얼에서는 staticclass를 UClass 라는 이름으로 만들어 놨습니다. 

	UCLASS 가 붙어 만들어진 언리얼 클래스들은 멤버 함수로 StaticClass(); 라는 함수가 있는데 반환 타입이 UClass 입니다. StaticClass 함수를 따라 들어가보면 Field 라는 타입을들 
	반환한다던가 하는 익숙한 모습이 보입니다. FieldClass 라는것도 따라 들어가보면 이름과 고유 넘버 등 메타 데이터들을 가지고 있습니다. 

	그렇기 때문에 언리얼의 빌드가 오래걸릴 수 밖에 없습니다. 클래스마다 이런 정보들을 하나하나 만들고 빌드를 해야하기 때문입니다. 
	여기까지 staticclass, 리플렉션에 대한 설명이고 

	두번째로 Tsubclassof 가 무엇인지를 알아보겠습니다. 
	얘도 메타 데이터를 저장할 수 있는 문법인데 UCLASS를 저장할 수 있습니다. 

	예를 들어서 Player 라는 클래스의 TsubclassOf 를 만들면 Bullet 이라는 클래스의 정보를 넣을 수 없게 됩니다. 
	TSubclassOf<Player> player;
	이렇게 만든 player 라는 TSubclassOf 는 Player를 상속받은 클래스들만 넣을 수 있도록 랩핑해놓은 클래스인겁니다. 

	마지막으로 Asset 이란 블루프린트, Sound 같은 완성된 객체를 저장하기위한 단위입니다. 

	그래서 GetAsset 함수를 다시 보겠습니다. 

	template<typename AssetType>
	inline AssetType* ULcAssetManager::GetAsset(const TSoftObjectPtr<AssetType>& AssetPointer, bool bKeepInMemory)
	{
		ULcAssetManager::StaticClass();

		AssetType* LoadedAsset = nullptr;
		const FSoftObjectPath& AssetPath = AssetPointer.ToSoftObjectPath();

		if (AssetPath.IsValid())
		{
			// 로딩이 되어있다? -> 바로 가져옴
			// 로딩이 안되어 있다 -> Null
			LoadedAsset = AssetPointer.Get();
			if (!LoadedAsset)
			{
				LoadedAsset = Cast<AssetType>(SynchronousLoadAsset(AssetPath));
				ensureAlwaysMsgf(LoadedAsset, TEXT("Failed to load asset [%s]"), *AssetPointer.ToString());
			}

			if (LoadedAsset && bKeepsInMemory)
			{
				// 여기서 AddLoadAsset은 메모리에 상주하기 위한 장치라고 생각하면 됨:
				// - 한번 등록되면 직접 내리지 않는한 Unload가 되지 않음 (== 캐싱)
				Get().AddLoadedAsset(Cast<UObject>(LoadedAsset));
			}
		}

		return LoadedAsset;
	}

	인자로 받은 AssetPointer 에서 FSoftObjectPath 를 추출해서 경로가 유효한지를 체크하고 이어서 AssetPointer를 .Get() 하고 있습니다. 이게 뭐냐면
	이 에셋이 로딩이 이미 되어있다면 바로 가져오고 로딩이 아직 안되있다면 null을 반환합니다. 
	그렇기 때문에 에셋이 로딩되어있는지를 확인하면서 로딩이 되어 있지 않다면 SynchronousLoadAsset을 실행하면서 동기 로딩을 진행합니다. 

	반면 bKeepInMemory 과 LoadedAsset 이 다 null 이 아니라면 Get().AddLoadedAsset 을 호출하는데 
	AssetManager의 Get은 싱글톤 패턴으로 GEngine에서 에셋매니저를 가져오는 함수였고 AddLoadedAsset 에서 LoadedAsset 은 위에서 UPROPERTY를 붙혀서 만들었던 
	TSet<TObjectPtr<const UObject>> LoadedAssets; 입니다. 
	결국 TSet 에 LoadedAsset 이라는 에셋을 추가하는건데 한번 래핑을 해둔겁니다. 
	AddLoadedAsset 함수를 보면 

	void ULcAssetManager::AddLoadedAsset(const UObject* Asset)
	{
		if (ensureAlways(Asset))
		{
			FScopeLock Lock(&SyncObject);
			LoadedAssets.Add(Asset);
		}
	}
	SyncObject 라는걸 락을 걸고 Add를 하고 있습니다. 

	락을 거는건 멀티스레드 환경에서 메모리침범을 막기위해 격리를 시키는 개념이었습니다. 

	PRAGMA_DISABLE_OPTIMIZATION
	void ULcAssetManager::StartInitialLoading()
	{
		Super::StartInitialLoading();
	}
	PRAGMA_ENABLE_OPTIMIZATION

	이런 함수를 하나 만들어 뒀었는데 StartInitialLoading 라는 줄에 중단점을 걸고 실행해봅니다. 
	그런데 그전에 언리얼엔진에서 기본 에셋매니저를 직접 만든 LcAssetManager 라고 설정을 해줘야하는데 프로젝트 세팅 -> AssetManager 에서 설정할 수 있습니다.

	처리후 프로젝트 실행을 해보면 언리얼 엔진 로딩중에 중단점이 걸리는걸 알 수 있습니다. 
	이게 무슨 의미냐면 컨텐츠작업을 진행하던 지금까지에서는 언리얼에서 멀티스레드 프로그래밍에대해 따로 생각하지 않아도 되도록 로직이 짜여있는데 
	예외가 있다면 에디터가 완전히 실행되기 전에는 멀티스레드가 세이프 하지않습니다. 그래서 LcAssetManager 의 코드에서는 락을 걸면서 스레드 세이프하게 코드를 짜야합니다. 

	그런데 LoadedAssets 라는 곳에 로딩을 해뒀던 에셋들을 왜 관리를 할까요 
	한번 로딩한 데이터들은 마음대로 삭제되면 안됩니다. 언제 다시 사용해야할지 모르기 때문인데 그런 에셋들을 TSet 에 담아서 관리하면 자동으로 메모리 해제가 되는걸 방지 할 수 있습니다. 
}


# 4 Experience
{
	Experience 라는것이 뭐냐면 Lyra 프로젝트의 근간을 이루는 개념입니다. 

	예를 들어서 FPS 모드를 진행하다 AOS 모드로 넘어갈때 게임모드를 변경합니다. 
	그런데 게임모드가 굉장히 무겁습니다. 무겁다는건 게임모드가 세팅하고 있는 양이 많다는겁니다. 왜 이렇게 됐냐면 
	언리얼엔진이 4버전에서 5버전으로 넘어와도 그동안 사용하던 코딩방식을 사용해도 전혀 문제가 없게끔 만든다고 하다가 게임모드가 가지고 있는 기능들이 많아진겁니다. 

	언리얼엔진에서 게임모드를 상속받아서 C++ 클래스를 만들려고 검색해보면 GameMode 상위에 GameModeBase 가 있습니다. 
	GameModeBase 는 그냥 게임모드보다 좀 더 가벼운 버전이라고 만든 것이지만 사실 이것도 무거운 편입니다. 

	그래서 라이라 프로젝트에서는 게임모드를 하나만 사용합니다. 게임모드를 교체하면서 사용하는게 아니라 동일한 하나의 게임모드만 사용하고 
	게임모드를 변경을 할때 Experience 라는 새로운 개념을 사용해 모드를 변경합니다. 

	즉, Experience 는 개임 모드를 대체하는 작은 게임모드라고 할 수 있습니다. 

	실습을 하기위해서 일단 게임모드가 하나는 있어야합니다. GameModeBase를 상속받아서 LcGameMode 라는 이름으로 C++ 클래스를 하나 생성해주겠습니다. Source 디렉토리 내에 GameModes 
	폴더를 하나 더 만들어 여기에 관리를 해주고 이어서 PrimaryDataAsset 을 상속받은 C++ 클래스를 하나 더 만들어줄건데 이름을 LcUserFacingExperience 라고 짓겠습니다. 
	한번더 PrimaryAsset 를 상속받은 LcExperienceDefinition 을 생성합니다. 마지막으로 다시 PrimaryAsset 를 상속받은 LcPawnData 클래스를 추가하는데 이건 Source/Character 디렉터리에 생성해주겠습니다.

	이 구조가 라이라 프로젝트에서 사용하는 구조라 따라했습니다. 

	이제 만든 파일들을 수정해볼건데 일단 아직 LcGameMode 는 건드리지 않을 겁니다. 
	건드릴건 먼저 LcUserFacingExperience 입니다. 이 Experience 라는게 위에서 예시를든 FPS, AOS 각각 모드 하나를 말하는겁니다. 

	지금 만든 파일들이 어떻게 동작하는지 대략 말해보겠습니다. LcUserFacingExperience 에서는 Map 과 Definition을 들고 있는데 Map 은 말그대로 소환사의 협곡같은 맵에 대한 데이터나 아이디 이고 
	Definition 은 다시 PawnData 를 들고 있습니다. PawnData 는 어떤 폰을 소환할건지 또 인풋을 어떻게 할건지 그리고 스킬같은 어빌리티는 어떤것들이 있는지를 가지고 있을겁니다. 
	이 것들을 다 위에서 만든 LcUserFacingExperience, LcExperienceDefinition, LcPawnData 들이 이것입니다. 

	LcPawnData 는 그냥 생성자만 만들고 생성자에선 Super(ObjectInitializer) 추가합니다. 
	LcExperienceDefinition 에서는 DefaultPawnData 와 GameFeaturesToEnable 을 들고 있는데 일단 DefaultPawnData 는 LcPawnData 을 말하는겁니다. 
	
	Experience 는 좀 더 가벼워진 게임모드인데 그에 필요한 데이터들도 들고 있는 형태이다 이정도로 이해하고 있으면 되겠습니다. 

	원래 게임모드를 설정할때 월드 세팅에서 게임모드를 설정했는데 이것을 None으로 두고 에디터의 프로젝트 세팅에서 GameMode 를 검색해서 여기를 LcGameModeBase 로 설정하는겁니다. 
	그래서 게임모드는 여기서 변화가 없고 앞으로는 Experience 로 모드를 변화하게끔 합니다. 
}


# 5 Map
{
	먼저 LcUserFacingExperience 를 구성하는 두가지 MapId, ExperienceId 중 Map 에 대해 알아보겠습니다. 

	라이라 프로젝트를 실행시켜보면 이제 각각 포탈로 표현되어있는 여러 게임 모드들이 이제 Experience 라는걸 알 수 있습니다. 정확히는 각각 UserFacingExperience 들입니다. 
	그리고 라이라 프로젝트의 Experience 중에서는 FrontEnd 라는 이름의 Experience 가 있는데 이건 게임모드가 아니라 게임에서 ESC 를 눌렀을때 화면, 로그인 화면 같은건데 
	Experience 는 단순히 게임모드뿐만 아니라 UI적 화면전환으로도 사용할 수 있다는걸 알 수 있습니다. 

	일단 이번에 이 Experience 들이 배치되어있는 맵 까지 만들어 보겠습니다. 

	Lc 프로젝트를 실행시켜서 콘텐츠 브라우저를 봅니다. 컨텐츠 폴더 아래로 System/DefaultEditormap 경로로 폴더를 만들고 여기에 새로 빈 레벨을 만듭니다. 
	위에서 창 옵션 버튼을 누르고 환경 라이트 믹서라는 설정창을 연 뒤 위에 뜨는 몇가지 버튼을 눌러 환경설정을 해줍니다. 다시 끄고 
	이제 레벨을 저장해주는데 L_DefaultEditorOverview 라는 이름으로 저장해줍니다. 

	다음은 바닥을 만들어줄건데 맵에 큐브를 추가한 후 로케이션을 모두 0으로 밀어준 후 스케일에서 x, y 값을 100 으로 설정해줍니다. 
	그러면 하얀 바닥이 생기는데 라이라에서는 바닥이 주황색이었는데 이것이 메테리얼입니다. 라이라 프로젝트를 실행해서 여기서 사용한 메테리얼을 가져올겁니다. 

	라이라 프로젝트의 바닥이 사용한 메테리얼을 우클릭 에셋 액션->이주 를 하는데 LC 프로젝트의 Content 폴더로 이주시킵니다. Content 가 아니면 이주가 안되거나 깨져서 이주되기도 합니다. 
	이제 LC 프로젝트의 바닥 메테리얼을 가져온걸로 설정해주고 프로젝트 세팅에서 시작맵과 기본맵을 L_DefaultEditorOverview 로 바꿔준 후 저장하면 
	맵은 준비가 되었습니다. 
}