Lyra 는 에픽게임즈에서 공식으로 배포하는 게임 프로젝트로 실제 현업수준의 거대한 프로젝트입니다. 
이 프로젝트는 언리얼 업데이트마다 그에 맞춰 업데이트되는 사실상 에픽게임즈에서 게임 제작 가이드라인의 역할을 하고 있고 
실제로 이 Lyra를 참조해 만든 게임들이 많다고 합니다. 

하지만 그만큼 내용이 방대하기 때문에 혼자 Lyra를 분석하기는 어렵습니다. 그래서 필요한 부분을 살펴보고 가져올 수 있는 방법이 있다면 가져와 사용하겠습니다. 

라이라 프로젝트는 모듈화가 잘 되어 있는 프로젝트입니다. 
이런 모듈화를 배워서 우리 프로젝트로 가져오는게 목표가 되겠습니다. 

#
에러 - 언리얼 5.5, 5.6 버전에서는 실행중 중단점이 호출되거나 빌드자체가 안되는데 5.4버전에서는 정상적으로 동작합니다. 
#

# 1 모듈 
{
	언리얼 프로젝트에서 모듈이 뭔지를 정의하자면 비쥬얼 스튜디오로 연 언리얼 프로젝트의 소스디렉토리 아래의 폴더 하나하나를 모듈이라고 할 수 있습니다. 적어도 라이라 프로젝트에서는
	그렇게 사용하고 있습니다. 그리고 프로젝트 아래의 플러그인 디렉토리와 그리고 프로젝트 파일까지 해서 
	모듈, 플러그인, 프로젝트 3가지가 언리얼 3대 요소라고 합니다. 

	이 3가지 요소의 개념을 정리하자면 
	모듈의 구성요소는 cpp 파일과 h 파일입니다. 매번 클래스를 추가하면서 생기는 파일들이었습니다. 프로젝트의 uproject 파일을 열어보면 모듈을 지웠다 작성하는걸로 프로젝트에 포함할지를
	정할 수 있습니다. 
	플러그인은 무엇이냐면 모듈들을 모은 개념입니다. 그러면 또 모듈은 cpp와 h로 이루어 져있을 겁니다. 플러그인도 마찬가지로 uproject 파일에서 Enable 값을 ture, false 를 주는걸로 
	포함 여부를 정할 수 있습니다. 

	모듈과 플러그인이 비슷해 보이는데 그 차이가 뭔지 알아보자면 에픽게임즈에서 실험적인 기능들을 플러그인으로 넣고 테스트를 합니다. 
	테스트를 하다가 이 플러그인이 안정성이 높고 유저들이 잘 사용한다 싶으면 그때 모듈로 옮기는 것입니다. 

	그럼 프로젝트가 뭐냐면 모듈과 플러그인을 모두 들고 있을 수 있는 큰 개념이고 거기에 한가지 더 컨텐츠 폴더도 들고 있을 수 있어서 에셋들도 관리합니다. 

	다시 쉽게 정리하자면 모듈은 이 프로젝트에서 안정적으로 사용할 수 있는 기능, 플러그인은 모듈들을 모아둔거지만 약간 외부에서 가져온 기능들로 안정성과 사용성이 모듈보다는 덜 
	증명된 기능 묶음, 그리고 프로젝트는 모듈, 플러그인, 에셋들을 모두 포함한 개념 이라고 할 수 있습니다. 

	새로만든 프로젝트를 보면 기본적으로 모듈이 하나 생성되어 있습니다. 
	프로젝트명.cpp, 프로젝트명.h 가 그것들인데 여기의 상단에는 IMPLEMENT_PRIMARY_GAME_MODULE 이라는 define이 있습니다. 이 define 함수는 게임모듈을 정의 하고 등록하는데 
	이때 인자로 FDefaultGameModuleImpl 을 주면 디폴트 모듈로 LC_5_4 로 등록합니다. 

	클래스를 만들면서 FDefaultGameModuleImpl 를 상속받게 되면 기본 모듈을 상속받은 나만의 커스텀 모듈을 만들 수 있습니다. 
	이때 중요한것은 지금 만든 모듈을 엔진에 사용하라고 명시를 해줘야합니다. 

	IMPLEMENT_PRIMARY_GAME_MODULE의 인자로 FDefaultGameModuleImpl 대신에 지금 새로 만든 커스텀 모듈을 넣어주는 것으로 새 커스텀 모듈을 사용하도록 명령을 한것입니다. 
	이 모듈을 만들고 사용하도록 하는 기술을 라이라에서 사용하고는 있지 않지만 일단 모듈에 대해 알기 위해서 실습을 해봅니다. 
	새 모듈의 StartModule 멤버 함수를 만들어 중단점을 걸고 실행해보면 언리얼 에디터가 완전 실행되기전에 중단점에 걸립니다. 

	주의해야할 점이 있습니다. 
	라이라 프로젝트에서 지금 배운 IMPLEMENT_PRIMARY_GAME_MODULE 부분을 확인할건데 라이라 프로젝트는 소스 폴더에서도 라이라 게임과 라이라 에디터모듈 두개로 나뉘어 있습니다. 
	그 중에 라이라 게임 모듈 cpp 파일에서 IMPLEMENT_PRIMARY_GAME_MODULE 함수를 사용하고 라이라 에디터 모듈에서는 IMPLEMENT_MODULE 로 설정하고 있습니다. 

	IMPLEMENT_PRIMARY_GAME_MODULE는 이름에서 알 수 있듯이 프로젝트에서 딱 하나만 설정할 수 있습니다. 두개의 모듈을 설정하면 실행이 되지 않습니다.
	거기에 에러가 이상하게 뜨기 때문에 문제를 알기도 힘듭니다. 
	그렇기 때문에 라이라 프로젝트처럼 라이라 게임에서 IMPLEMENT_PRIMARY_GAME_MODULE을 사용했다면 라이라 에디터에서 IMPLEMENT_MODULE를 사용해도록 해줘야합니다. 

	가장 중요한 기초 모듈에 IMPLEMENT_PRIMARY_GAME_MODULE를 하고 그 외의 모듈에서는 IMPLEMENT_MODULE를 호출해 줘야합니다. 

	LC 프로젝트에서 새로 만든 모듈에 로그를 하나 찍어서 테스트를 해봅니다. 여기까지 실습으로 모듈이 뭔지에 대한 개념 그리고 커스텀 모듈이 잘 설정되었는지를 확인할 수 있습니다. 
}


# 2 로그 
{
		앞으로 디버깅을 하면서 로그를 많이 찍어볼건데 언리얼에서 로그를 커스텀 할 수 있게 지원을 해줘서 디버깅에 필요한 로그들을 가독성 있게 볼 수 있도록 할것입니다. 
	LC 프로젝트를 실행하고 C++ 클래스를 생성하는데 None을 선택해서 아무것도 상속받지 않고 생성을 해주는데 기본생성되는 클래스는 지워주겠습니다. 

	헤더 파일에 두가지 헤더를 추가해주는데 Containers/UnrealSting.h 와 Logging/LogMacros.h 입니다. 
	그리고 나서 
	DECLARE_LOG_CATEGORY_EXTERN(LogLC, Log, All);
	이런 매크로를 사용해주게 되면 LogLC 라는 새 로그 카테고리를 만들게 되는겁니다. 그런데 헤드에만 선언하면 안되고 
	cpp 파일에서 다시 
	DEFINE_LOG_CATEGORY(LogLC);
	이렇게 정의 해줘야합니다.

	새로 만든 로그 카테고리를 어떻게 사용하냐면 이전에 로그를 찍을때 LogTemp 를 사용했던 부분을 LogLC 로 바꿔주면 이 카테고리의 로그로 출력이 됩니다. 
	앞으로 로그를 찍을때 카테고리로 나눠서 사용하게 되면 출력 로그에서 검색해 확인 하기 편해집니다. 
}


# 3 에셋 매니저
{
	에셋이란 모델링이나 사운드파일 같이 프로그래밍 외의 직군쪽에서 만든 리소스들을 말합니다. 
	이런 에셋을 매니징하는 에셋 매니저를 프로젝트에 추가할겁니다. 왜 에셋매니저를 사용하냐면 이것을 사용하기 전에는 직접 에셋을 임포트하고 수정하고 싶은 옵션을 가져와서 
	수정을 하게되는데 이동작들이 하드코딩적입니다. 에셋의 바꾸고 싶은 옵션의 경로가 바꾼다고 하면 이 에셋을 수정한 모든곳을 수정해야합니다.

	그래서 에셋매니저를 사용하게 되는데 에셋매니저를 따라 들어가 설명을 보면 싱글톤으로 PrimaryAsset 을 로딩이나 언로딩을 한다고 합니다. 프라이머리 에셋이 뭔지는 뭐르겠지만
	일단 넘어갑니다. 

	싱글톤은 프로젝트내에서 유일성을 보장해야하는 패턴입니다.
	에셋매니저에서 Get 이라는 함수를 사용할텐데 여기서 GEngine 에서 에셋 매니저를 가져와 ULcAssetManager 라는 제가 사용할 에셋매니저 타입으로 캐스팅해서 리턴을 할겁니다. 
	GEngine 이라는 글로벌로 사용하는 엔진 객체를 사용하면 이 에셋 매니저를 Get으로 가져올때마다 새로 생성하는게 아닌겁니다. 

	ShouldLogAssetLoads 라는 static 멤버 함수를 하나 추가할겁니다. 이 함수는 새로운 기법하나를 소개하는 용도인데 
	커맨드 프롬프트에서 LogAssetLoads 라는 문자를 포함하고 있는지를 불리언으로 반환하는 함수입니다. 

	bool ULcAssetManager::ShouldLogAssetLoads()
	{
		const TCHAR* CommandLineContent = FCommandLine::Get();
		static bool bLogAssetLoads = FParse::Param(CommandLineContent, TEXT("LogAssetLoads"));
		return bLogAssetLoads;
	}

	커맨드 라인에서 LogAssetLoads 라는 문자열이 있는지를 찾는다고 했는데 언리얼엔진을 실행하는데 왠 커맨드라인 인가 싶을수 있습니다. 
	그런데 프로젝트의 속성 - 디버그 - 명령 인수 를 보면 프로젝트의 uproject 을 실행하면서 뒤에 -skipcompile 이라는 인자를 같이 주고 있습니다. 여기에 추가로 
	-LogAssetLoads를 추가하게되면 위의 ShouldLogAssetLoads 함수가 true 로 반환되는겁니다. 
	이 함수를 통해 FCommandLine 이라는 함수에서 인자를 가져와 활용할 수 있다를 보여주고 언리얼에서도 커맨드라인 인자를 넣을 수 있다는것도 알 수 있었습니다. 

	SynchronousLoadAsset 이라는 멤버 함수를 하나 더 추가하겠습니다. 
	함수 명칭에서 알 수 있듯이 동기화 적으로 에셋을 로드한다는 뜻입니다. 
	다시 동기와 비동기에 대해 집고 넘어가자면 동기식 함수는 A,B라는 함수가 있고 둘 다 호출을 해야할때 A함수의 모든 로직을 실행한 후 B의 로직을 실행하기 시작하는 방식이고
	비동기는 A함수를 실행하는 중에도 B함수를 쓰레드를 할당하거나 하는 방법들로 같이 실행해 A의 로직이 끝나는것과 상관없이 B를 실행하는 것입니다. 

	보통 온라인 게임 로직에서는 비동기 방식을 선호하게 되는데 당연히 동시다발적으로 여러 동작이 일어날텐데 동기방식으로 처리하면 게임 경험이 많이 불쾌해질것입니다. 
	하지만 무조건 비동기 방식을 채택하는건 아닙니다. 

	동기 방식의 장점은 일단 비동기 방식보다 속도가 빠르고 그리고 로직 진행 순서도를 확인하기 쉽습니다. 
	그래서 동기 방식을 어디서 많이 쓰냐면 게임을 시작하거나 맵이 전환되거나하는 로딩 시간때 주로 사용합니다 어짜피 이 시간에는 유저가 조작하지 않기 때문에 
	속도가 중요하고 로직순서에 따른 문제를 최소화할 수 있는 동기 로딩을 사용하는것입니다. 그래서 이 함수 SynchronousLoadAsset 를 만든 이유가 
	인게임 중에 동기 로딩이 많아지면 프레임 드랍이 일어날 건데 이런 문제가 동기로딩에서 문제가 생기는지 찾기위해 만든겁니다.  

	UObject* ULcAssetManager::SynchronousLoadAsset(const FSoftObjectPath& AssetPath)
	{
		// 해당 함수를 따로 만든 이유는 'synchronous load asset이 불필요하게 하는 것이 없는지 확인하기 위함'
		if (AssetPath.IsValid())
		{
			// FScopeLogTime을 확인해보자:
			TUniquePtr<FScopeLogTime> LogTimePtr;
			if (ShouldLogAssetLoads())
			{
				// 단순히 로깅하면서, 초단위로 로깅 진행
				LogTimePtr = MakeUnique<FScopeLogTime>(*FString::Printf(TEXT("synchronous loaded assets [%s]"), *AssetPath.ToString()), nullptr, FScopeLogTime::ScopeLog_Seconds);
			}

			// 여기서 두가지 분기:
			// 1. AssetManager가 있으면, AssetManager의 StreamableManager를 통해 정적 로딩
			// 2. 아니면, FSoftObjectPath를 통해 바로 정적 로딩
			if (UAssetManager::IsValid())
			{
				return UAssetManager::GetStreamableManager().LoadSynchronous(AssetPath);
			}

			// if asset manager is not ready, use LoadObject()
			// - 슥 보면, StaticLoadObject가 보인다: 
			// - 참고로, 항상 StaticLoadObject하기 전에 StaticFindObject를 통해 확인하고 실패하면 진짜 로딩함
			return AssetPath.TryLoad();
		}

		return nullptr;
	}

	코드를 보면 FScopeLogTime 이라는 구조체를 UniquePtr로 만들어 LotTimePtr 이라고 들고 있습니다. 이 FScopeLogTime 구조체의 설명을 보면 로그시간을 초당으로 누적 전달하는 구조체입니다.
	위에서 만들어 놓은 ShouldLogAssetLoads 함수를 통해 커맨드라인에 LogAssetLoads 가 있다면 참을 반환해 조건문으로 들어오고 
	FScopeLogTime 를 위의 인자처럼 ScopeLog_Seconds 를 주게되면 초단위로 이 함수가 얼마나 걸렸는지 초단위로 알 수 있습니다. 그래서 동기성 함수를 실행하면서 얼마나 걸린지를 체크 할 수 있습니다. 
	그리고 AssetManager 가 유효하다면 StreamManager 라는걸 가져와서 동기화 로딩을 진행합니다. StreamableManager가 뭐냐면 동기로딩 비동기로딩을 관리하는 클래스입니다. 
	만약 AssetManager가 아직 생성이 안되서 없다면 인자로 받은 에셋 자체에 대해 TryLoad 를 진행합니다. 
	TryLoad도 내부적으로 로딩을 하는건 똑같습니다. 하지만 TryLoad를 따라 들어가 설명을 보면 굉장히 느리다고 합니다. 
	LoadSynchronous 와 TryLoad 둘 모두 로딩을 끝낸 데이터는 캐싱을해서 메모리에 올려두기 때문에 다시 로딩을 시도한다고 해도 캐싱해뒀던 데이터를 가져와 사용합니다.

	그래서 SynchronousLoadAsset 이란 함수는 거의 LoadSynchronous 함수를 그대로 사용하는데 동기로딩을 하는 시간을 한번 재보는 래핑을 한겁니다. 

	지금 이 함수가 정확히 뭔지 다시 비유하자면 게임에서 나중에 여러가지 에셋들 예를 들어 여러 무기들 혹은 캐릭터의 아바타등이 있을겁니다. 그런데 게임이 오래되면 각 종류마다 1000가지의 종류가 또 나눠질 수도 있습니다. 
	그런데 이것들을 항상 모든 클라이언트에서 로딩을 해놔서 메모리에 올려 놓을 수 없습니다. 이런걸 필요한 것들만 로딩하는게 지금 SynchronousLoadAsset 함수 내의 LoadSynchronous 와 TryLoad 입니다. 

	여기서 추가로 게임 로직을 쭉 진행중에 어떤 함수 A의 어느 부분에서 확 느려지는걸 발견을 했다고 하겠습니다. 
	예를들어서 1000초가 걸린다고했을때 위의 LogTimePtr 부분 코드 때문에 이 에셋을 로딩할때 1000초가 걸린다는걸 쉽게 체크할 수 있게 되는겁니다. 
	그래서 이 에셋로드를 동기화 로딩을 하면 안되겠다고 판단이 가능해 집니다. 

	SynchronousLoadAsset 함수에서 한가지 더 집고 넘어갈 부분이 파라매터인 FSoftObjectPath에 대해서인데 
	에셋들이 여러 종류가 있을 수 있습니다. 사운드, 메시, 블루프린트 같은 에셋들이 있다고 할때 위에서 말했듯이 모든 에셋들을 다 메모리에 들고 있을 수는 없습니다. 
	그래서 필요한 에셋을 로드를 해야하는데 그 필요한 에셋을 가리키는게 이 FSoftObjectPath 입니다. 에셋들이 프로젝트 디렉터리 안에서도 해당 경로가 있을겁니다. 

	언리얼 엔진에서 이 경로를 확인 할 수 있는데 언리얼 엔진을 실행시켜서 테스트용 아무 에셋을 하나 만들어 컨트롤 V 를 한 후 메모장에 붙여넣기를 해보면 
	이 에셋이 위치한 경로가 뜹니다. 이 경로를 들고 있는게 FSoftObjectPath의 역할입니다. 
	SynchronousLoadAsset 에 인자로 몇백메가바이트 혹은 그이상 갈 수도 있는 에셋자체를 주는게 아니라 그 경로를 주는겁니다. 마치 객체와 포인터를 보는것 같습니다. 

	다음은 템플릿을 활용한 함수들을 추가합니다. 

	template<typename AssetType>
	inline AssetType* ULcAssetManager::GetAsset(const TSoftObjectPtr<AssetType>& AssetPointer, bool bKeepInMemory)
	{
		AssetType* LoadedAsset = nullptr;
		const FSoftObjectPath& AssetPath = AssetPointer.ToSoftObjectPath();

		if (AssetPath.IsValid())
		{
			// 로딩이 되어있다? -> 바로 가져옴
			// 로딩이 안되어 있다 -> Null
			LoadedAsset = AssetPointer.Get();
			if (!LoadedAsset)
			{
				LoadedAsset = Cast<AssetType>(SynchronousLoadAsset(AssetPath));
				ensureAlwaysMsgf(LoadedAsset, TEXT("Failed to load asset [%s]"), *AssetPointer.ToString());
			}

			if (LoadedAsset && bKeepsInMemory)
			{
				// 여기서 AddLoadAsset은 메모리에 상주하기 위한 장치라고 생각하면 됨:
				// - 한번 등록되면 직접 내리지 않는한 Unload가 되지 않음 (== 캐싱)
				Get().AddLoadedAsset(Cast<UObject>(LoadedAsset));
			}
		}

		return LoadedAsset;
	}

	template<typename AssetType>
	inline TSubclassOf<AssetType> ULcAssetManager::GetSubclass(const TSoftClassPtr<AssetType>& AssetPointer, bool bKeepInMemory)
	{
		TSubclassOf<AssetType> LoadedSubclass;

		const FSoftObjectPath& AssetPath = AssetPointer.ToSoftObjectPath();
		if (AssetPath.IsValid())
		{
			LoadedSubclass = AssetPointer.Get();
			if (!LoadedSubclass)
			{
				LoadedSubclass = Cast<UClass>(SynchronousLoadAsset(AssetPath));
				ensureAlwaysMsgf(LoadedSubclass, TEXT("Failed to load asset class [%s]"), *AssetPointer.ToString());
			}

			if (LoadedSubclass && bKeepInMemory)
			{
				Get().AddLoadedAsset(Cast<UObject>(LoadedSubclass));
			}
		}

		return LoadedSubclass;
	}

	추가한 두가지 함수는 거의 동일한데 반환하는 타입이 AssetType* 인것과 TSubclassOf<AssetType> 인것 밖에 차이가 없습니다. 
	둘 모두 AssetPointer가 가리키는 에셋의 주소를 보고 유효한지 체크 유효하다면 SynchronousLoadAsset을 해서 로드 해오고 로드가 실패했다면 로그를 찍습니다. 
	또다른 매개변수인 이 에셋을 캐싱해둘지 불리언으로 받아 그 값에 따라 AddLoadedAsset 함수를 통해 계속 메모리에 올려둘지를 정합니다. 

	별개의 이야기로 여기 등장하는 용어들과 비슷한 용어를 한번 정리 해보겠습니다. 

	Asset : 블루프린트, 사운드, 메시 등
	Tsubclassof : 특정 클래스의 서브클래스의 타입정보 
	CDO : 클래스의 기본 인스턴스
	staticclass : 리플렉션을 가지고 있는 메타데이터 

	간단하게 이렇게 개념을 정리 할 수 있습니다. 
	그런데 여기서 staticclass 를 설명하는 말중 리플렉션이 무엇인지 좀 더 알아보겠습니다. 
	일단 C++ 자체에는 리플렉션이라는 기능이 없고 그래서 C# 을 통해 설명을 해보겠습니다. 

	리플렉션 이라는 용어의 이름을 보면 반사라는 뜻이 있는데 리플렉션은 런타임 단계에서 클래스에 대한 정보를 알 수 있게 해주는 것입니다. 
	이게 무슨 말이냐면 

	class Test
	{
		public int Num = 0;
		public string Name = "ABC";

		public void Print()
		{
			Console.WriteLine($"{Num}, {Name}");
		}
	}

	이런 클래스가 있고 

	static void Main(string[] args)
	{
		foreach (var Filed in typeof(Test).GetFields())
		{
			Console.WriteLine(Field.Name);
		}
	}

	이렇게 Test 클래스의 타입을 가지고 GetFields 라는 함수로 무언가 데이터를 가져와 출력해보려고 합니다. 

	이 프로그램을 실행해보면 Num과 Name이 한줄씩 출력됩니다. Test 객체를 만들어서 멤버변수를 가져와 본것이 아닌데 
	Test클래스가 가지고 있는 멤버 변수의 식별자를 가져와 버립니다. 
	GetFeilds 라는 함수뿐만아니라 

	foreach (var Method in typeof(Test).GetMethods())
	{
		Console.WriteLine(Method.Name);
	}

	Method를 가져오는 함수를 사용해 실행해보면 Print, GetType, ToString, Equals, GetHashCode 라는 문자열들이 출력됩니다. 

	리플렉션은 이런식으로 런타임 단계에서 클래스의 정보들을 알 수 있는 것을 말하는데 그 활용은 이렇게도 가능합니다. 

	static void Main(string[] args)
	{
		// 빈 Test 객체 생성
		Test a = new();

		// a 의 num값을 출력해보기 
		Console.WriteLine(a.Num);

		foreach (var Filed in typeof(Test).GetFileds())
		{
			// 리플렉션으로 Test에 Num이라는 이름의 변수가 있는지를 체크하고 있다면 인자로 넘겨준 객체의 Num 값을 수정
			if (Filed.Name = "Num")
				Filed.SetValue(a, 100);
		}

		// 수정되었는지 출력
		Console.WriteLine(a.Num);
	}

	C++ 자체 기능으로는 이런 리플렉션 기능이 없습니다. 
	하지만 언리얼같은 엔진에서는 리플렉션 기능이 필요합니다. 언리얼 엔진을 실행시켜서 에셋들의 Details를 살펴보면 이 에셋에서 UPROPERTY매크로를 붙힌 변수들을 
	엔진에서 UI적으로 수정할 수 있습니다. 이 기능도 리플렉션으로 데이터를 가져와 구현하는 것입니다. 

	언리얼엔진에서는 언리얼 빌드 툴, 언리얼 헤더 툴 등으로 C++ 에서도 리플렉션이 가능하도록 만들어 줬습니다. 그 흔적을 찾아보면 
	프로젝트의 Build 파일, Target 파일들이 C#으로 만들어져 있습니다. 

	코드로는 어떤 부분이냐면 UPROPERTY매크로를 붙힌 코드는 리플렉션이 필요하다고 기억을 해두는데 언리얼로 만든 헤더 파일에 기본적으로 추가 되어있는 .generated.h 파일과 
	클래스의 맨위에 자동으로 입력되어있는 GENERATED_BODY() 입니다.

	그런데 이런 리플렉션을 하는 대상인 이 클래스의 변수들의 이름이나 함수들의 이름을 C++의 기본 클래스인 class 가 가지고 있는게 아니라 위에서 알아본 staticclass 가 가지고 있고
	언리얼에서는 staticclass를 UClass 라는 이름으로 만들어 놨습니다. 

	UCLASS 가 붙어 만들어진 언리얼 클래스들은 멤버 함수로 StaticClass(); 라는 함수가 있는데 반환 타입이 UClass 입니다. StaticClass 함수를 따라 들어가보면 Field 라는 타입을들 
	반환한다던가 하는 익숙한 모습이 보입니다. FieldClass 라는것도 따라 들어가보면 이름과 고유 넘버 등 메타 데이터들을 가지고 있습니다. 

	그렇기 때문에 언리얼의 빌드가 오래걸릴 수 밖에 없습니다. 클래스마다 이런 정보들을 하나하나 만들고 빌드를 해야하기 때문입니다. 
	여기까지 staticclass, 리플렉션에 대한 설명이고 

	두번째로 Tsubclassof 가 무엇인지를 알아보겠습니다. 
	얘도 메타 데이터를 저장할 수 있는 문법인데 UCLASS를 저장할 수 있습니다. 

	예를 들어서 Player 라는 클래스의 TsubclassOf 를 만들면 Bullet 이라는 클래스의 정보를 넣을 수 없게 됩니다. 
	TSubclassOf<Player> player;
	이렇게 만든 player 라는 TSubclassOf 는 Player를 상속받은 클래스들만 넣을 수 있도록 랩핑해놓은 클래스인겁니다. 

	마지막으로 Asset 이란 블루프린트, Sound 같은 완성된 객체를 저장하기위한 단위입니다. 

	그래서 GetAsset 함수를 다시 보겠습니다. 

	template<typename AssetType>
	inline AssetType* ULcAssetManager::GetAsset(const TSoftObjectPtr<AssetType>& AssetPointer, bool bKeepInMemory)
	{
		ULcAssetManager::StaticClass();

		AssetType* LoadedAsset = nullptr;
		const FSoftObjectPath& AssetPath = AssetPointer.ToSoftObjectPath();

		if (AssetPath.IsValid())
		{
			// 로딩이 되어있다? -> 바로 가져옴
			// 로딩이 안되어 있다 -> Null
			LoadedAsset = AssetPointer.Get();
			if (!LoadedAsset)
			{
				LoadedAsset = Cast<AssetType>(SynchronousLoadAsset(AssetPath));
				ensureAlwaysMsgf(LoadedAsset, TEXT("Failed to load asset [%s]"), *AssetPointer.ToString());
			}

			if (LoadedAsset && bKeepsInMemory)
			{
				// 여기서 AddLoadAsset은 메모리에 상주하기 위한 장치라고 생각하면 됨:
				// - 한번 등록되면 직접 내리지 않는한 Unload가 되지 않음 (== 캐싱)
				Get().AddLoadedAsset(Cast<UObject>(LoadedAsset));
			}
		}

		return LoadedAsset;
	}

	인자로 받은 AssetPointer 에서 FSoftObjectPath 를 추출해서 경로가 유효한지를 체크하고 이어서 AssetPointer를 .Get() 하고 있습니다. 이게 뭐냐면
	이 에셋이 로딩이 이미 되어있다면 바로 가져오고 로딩이 아직 안되있다면 null을 반환합니다. 
	그렇기 때문에 에셋이 로딩되어있는지를 확인하면서 로딩이 되어 있지 않다면 SynchronousLoadAsset을 실행하면서 동기 로딩을 진행합니다. 

	반면 bKeepInMemory 과 LoadedAsset 이 다 null 이 아니라면 Get().AddLoadedAsset 을 호출하는데 
	AssetManager의 Get은 싱글톤 패턴으로 GEngine에서 에셋매니저를 가져오는 함수였고 AddLoadedAsset 에서 LoadedAsset 은 위에서 UPROPERTY를 붙혀서 만들었던 
	TSet<TObjectPtr<const UObject>> LoadedAssets; 입니다. 
	결국 TSet 에 LoadedAsset 이라는 에셋을 추가하는건데 한번 래핑을 해둔겁니다. 
	AddLoadedAsset 함수를 보면 

	void ULcAssetManager::AddLoadedAsset(const UObject* Asset)
	{
		if (ensureAlways(Asset))
		{
			FScopeLock Lock(&SyncObject);
			LoadedAssets.Add(Asset);
		}
	}
	SyncObject 라는걸 락을 걸고 Add를 하고 있습니다. 

	락을 거는건 멀티스레드 환경에서 메모리침범을 막기위해 격리를 시키는 개념이었습니다. 

	PRAGMA_DISABLE_OPTIMIZATION
	void ULcAssetManager::StartInitialLoading()
	{
		Super::StartInitialLoading();
	}
	PRAGMA_ENABLE_OPTIMIZATION

	이런 함수를 하나 만들어 뒀었는데 StartInitialLoading 라는 줄에 중단점을 걸고 실행해봅니다. 
	그런데 그전에 언리얼엔진에서 기본 에셋매니저를 직접 만든 LcAssetManager 라고 설정을 해줘야하는데 프로젝트 세팅 -> AssetManager 에서 설정할 수 있습니다.

	처리후 프로젝트 실행을 해보면 언리얼 엔진 로딩중에 중단점이 걸리는걸 알 수 있습니다. 
	이게 무슨 의미냐면 컨텐츠작업을 진행하던 지금까지에서는 언리얼에서 멀티스레드 프로그래밍에대해 따로 생각하지 않아도 되도록 로직이 짜여있는데 
	예외가 있다면 에디터가 완전히 실행되기 전에는 멀티스레드가 세이프 하지않습니다. 그래서 LcAssetManager 의 코드에서는 락을 걸면서 스레드 세이프하게 코드를 짜야합니다. 

	그런데 LoadedAssets 라는 곳에 로딩을 해뒀던 에셋들을 왜 관리를 할까요 
	한번 로딩한 데이터들은 마음대로 삭제되면 안됩니다. 언제 다시 사용해야할지 모르기 때문인데 그런 에셋들을 TSet 에 담아서 관리하면 자동으로 메모리 해제가 되는걸 방지 할 수 있습니다. 
}


# 4 Experience
{
	Experience 라는것이 뭐냐면 Lyra 프로젝트의 근간을 이루는 개념입니다. 

	예를 들어서 FPS 모드를 진행하다 AOS 모드로 넘어갈때 게임모드를 변경합니다. 
	그런데 게임모드가 굉장히 무겁습니다. 무겁다는건 게임모드가 세팅하고 있는 양이 많다는겁니다. 왜 이렇게 됐냐면 
	언리얼엔진이 4버전에서 5버전으로 넘어와도 그동안 사용하던 코딩방식을 사용해도 전혀 문제가 없게끔 만든다고 하다가 게임모드가 가지고 있는 기능들이 많아진겁니다. 

	언리얼엔진에서 게임모드를 상속받아서 C++ 클래스를 만들려고 검색해보면 GameMode 상위에 GameModeBase 가 있습니다. 
	GameModeBase 는 그냥 게임모드보다 좀 더 가벼운 버전이라고 만든 것이지만 사실 이것도 무거운 편입니다. 

	그래서 라이라 프로젝트에서는 게임모드를 하나만 사용합니다. 게임모드를 교체하면서 사용하는게 아니라 동일한 하나의 게임모드만 사용하고 
	게임모드를 변경을 할때 Experience 라는 새로운 개념을 사용해 모드를 변경합니다. 

	즉, Experience 는 개임 모드를 대체하는 작은 게임모드라고 할 수 있습니다. 

	실습을 하기위해서 일단 게임모드가 하나는 있어야합니다. GameModeBase를 상속받아서 LcGameMode 라는 이름으로 C++ 클래스를 하나 생성해주겠습니다. Source 디렉토리 내에 GameModes 
	폴더를 하나 더 만들어 여기에 관리를 해주고 이어서 PrimaryDataAsset 을 상속받은 C++ 클래스를 하나 더 만들어줄건데 이름을 LcUserFacingExperience 라고 짓겠습니다. 
	한번더 PrimaryAsset 를 상속받은 LcExperienceDefinition 을 생성합니다. 마지막으로 다시 PrimaryAsset 를 상속받은 LcPawnData 클래스를 추가하는데 이건 Source/Character 디렉터리에 생성해주겠습니다.

	이 구조가 라이라 프로젝트에서 사용하는 구조라 따라했습니다. 

	이제 만든 파일들을 수정해볼건데 일단 아직 LcGameMode 는 건드리지 않을 겁니다. 
	건드릴건 먼저 LcUserFacingExperience 입니다. 이 Experience 라는게 위에서 예시를든 FPS, AOS 각각 모드 하나를 말하는겁니다. 

	지금 만든 파일들이 어떻게 동작하는지 대략 말해보겠습니다. LcUserFacingExperience 에서는 Map 과 Definition을 들고 있는데 Map 은 말그대로 소환사의 협곡같은 맵에 대한 데이터나 아이디 이고 
	Definition 은 다시 PawnData 를 들고 있습니다. PawnData 는 어떤 폰을 소환할건지 또 인풋을 어떻게 할건지 그리고 스킬같은 어빌리티는 어떤것들이 있는지를 가지고 있을겁니다. 
	이 것들을 다 위에서 만든 LcUserFacingExperience, LcExperienceDefinition, LcPawnData 들이 이것입니다. 

	LcPawnData 는 그냥 생성자만 만들고 생성자에선 Super(ObjectInitializer) 추가합니다. 
	LcExperienceDefinition 에서는 DefaultPawnData 와 GameFeaturesToEnable 을 들고 있는데 일단 DefaultPawnData 는 LcPawnData 을 말하는겁니다. 
	
	Experience 는 좀 더 가벼워진 게임모드인데 그에 필요한 데이터들도 들고 있는 형태이다 이정도로 이해하고 있으면 되겠습니다. 

	원래 게임모드를 설정할때 월드 세팅에서 게임모드를 설정했는데 이것을 None으로 두고 에디터의 프로젝트 세팅에서 GameMode 를 검색해서 여기를 LcGameModeBase 로 설정하는겁니다. 
	그래서 게임모드는 여기서 변화가 없고 앞으로는 Experience 로 모드를 변화하게끔 합니다. 
}


# 5 Map
{
	먼저 LcUserFacingExperience 를 구성하는 두가지 MapId, ExperienceId 중 Map 에 대해 알아보겠습니다. 

	라이라 프로젝트를 실행시켜보면 이제 각각 포탈로 표현되어있는 여러 게임 모드들이 이제 Experience 라는걸 알 수 있습니다. 정확히는 각각 UserFacingExperience 들입니다. 
	그리고 라이라 프로젝트의 Experience 중에서는 FrontEnd 라는 이름의 Experience 가 있는데 이건 게임모드가 아니라 게임에서 ESC 를 눌렀을때 화면, 로그인 화면 같은건데 
	Experience 는 단순히 게임모드뿐만 아니라 UI적 화면전환으로도 사용할 수 있다는걸 알 수 있습니다. 

	일단 이번에 이 Experience 들이 배치되어있는 맵 까지 만들어 보겠습니다. 

	Lc 프로젝트를 실행시켜서 콘텐츠 브라우저를 봅니다. 컨텐츠 폴더 아래로 System/DefaultEditormap 경로로 폴더를 만들고 여기에 새로 빈 레벨을 만듭니다. 
	위에서 창 옵션 버튼을 누르고 환경 라이트 믹서라는 설정창을 연 뒤 위에 뜨는 몇가지 버튼을 눌러 환경설정을 해줍니다. 다시 끄고 
	이제 레벨을 저장해주는데 L_DefaultEditorOverview 라는 이름으로 저장해줍니다. 

	다음은 바닥을 만들어줄건데 맵에 큐브를 추가한 후 로케이션을 모두 0으로 밀어준 후 스케일에서 x, y 값을 100 으로 설정해줍니다. 
	그러면 하얀 바닥이 생기는데 라이라에서는 바닥이 주황색이었는데 이것이 메테리얼입니다. 라이라 프로젝트를 실행해서 여기서 사용한 메테리얼을 가져올겁니다. 

	라이라 프로젝트의 바닥이 사용한 메테리얼을 우클릭 에셋 액션->이주 를 하는데 LC 프로젝트의 Content 폴더로 이주시킵니다. Content 가 아니면 이주가 안되거나 깨져서 이주되기도 합니다. 
	이제 LC 프로젝트의 바닥 메테리얼을 가져온걸로 설정해주고 프로젝트 세팅에서 시작맵과 기본맵을 L_DefaultEditorOverview 로 바꿔준 후 저장하면 
	맵은 준비가 되었습니다. 
}


# 6 ExperienceList3D
{
	이제 라이라의 기본 맵을 만들었으니 이제 각 Experience 를 나타내는 포탈같은 것들을 만들어보겠습니다. 
	위에서 Experience 파일들을 만들었을때 가장 먼저 만들었던 ULcUserFacingExperience 가 상속한 클래스를 보면 UPrimaryDataAsset 입니다. 즉 데이터 파일에 불과 하다는거고 
	실제 사용되는곳이 어딘지 보면 ULcAssetManager 의 부모 클래스인 AssetManager 를 따라 들어가 설명을 읽어보면 싱글톤 패턴이면서 PrimaryAsset 을 로딩할지 언로딩할지를 
	응답한다고 되어있습니다. 
	즉, 저번에 에셋매니저를 만들면서 동기적 혹은 비동기적으로 로딩해 사용하게 만들었는데 그래도 상관은 없지만 언리얼에서 의도한 대로 PrimaryAsset 을 사용하면 많이 편리합니다. 
	PrimaryAsset 은 데이터의 묶음인데 이걸 편하게 로딩할 수 있는것입니다. 

	LcUserFacingExperience 파일을 언리얼엔진에서 사용하려면 엔진을 실행하고 콘텐츠 드로어에서 Playlists 폴더에다가 파일을 하나 추가해야합니다. 우클릭->기타->데이터에셋을 클릭한 후 
	LcUserFacingExperience 을 검색해 파일을 만들면 됩니다. PrimaryAsset 이 DataAsset 을 상속 받았기 때문에 이렇게 만들어 집니다. 
	이름을 DA_ExamplePlaylist 라고 짓고 테스트를 해볼건데 여기에 LcUserFacingExperience 의 멤버 변수들인 MapId, ExperienceId 를 설정할 수 있습니다. 
	하지만 MapId 를 설정하려고 보니 이전에 만들었던 맵인 L_DefaultEditorOverview 맵이 보이지 않습니다.
	그래서 스캔이라는 개념을 배워야합니다. 

	스캔이란 에셋매니저가 사용하기 위해 주시를 하고 있는것을 스캔이라고 합니다. 
	그러면 스캔과 로딩이 비슷하게 보입니다. 하지만 완벽하게 다른 개념입니다. 
	로딩은 어떤 에셋의 크기가 작을지 클지 모르기도 하고 RAM에 모든 에셋들을 다 올려놓지 못하니깐 엔진에서는 그냥 에셋의 경로만 알고 있고 사용할때 그 경로의 에셋을 가져오는것입니다. 
	이때 에셋의 경로로 이 에셋을 주시하고 있다고 할 수 있습니다. 
	스캔도 에셋매니저가 이 에셋이 존재한다는 것을 알고만 있는것입니다. 

	스캔은 어떻게 하냐면 언리얼 에디터의 프로젝트 세팅으로 가보면 에셋매니저 설정창이 있습니다. 이중에 스캔할 프라이머리 에셋 타입 창을 펼쳐서 설정합니다. 
	이 중에 인덱스를 열어보면 프라이머리 에셋 타입이 Map 으로 되어있고 에셋 베이스 클래스가 World 입니다. 그리고 그 밑에 디렉터리와 특정 에셋이라는 옵션이 있는데
	특정 옵션은 정말 딱 지정한 하나의 에셋을 스캔하는것입니다. 하나하나 직접 스캔하도록 설정하는 방법이기 때문에 너무 번거롭다면
	디렉터리 옵션을 보면되는데 이 옵션은 어떤 폴더를 지정하면 그 폴더 아래에 있는 에셋을 스캔합니다. 

	그런데 라이라 프로젝트에서는 맵을 특정 에셋 방식으로 스캔하고 있기 때문에 이대로 따라하겠습니다. 
	설정한 후 아까 만들었던 DA_ExamplePlaylist 의 MapId 를 살펴보면 스캔이 되어 있는걸 확인 할 수 있습니다. 

	Map은 설정했고 이어서 ExperienceId 를 설정해볼겁니다. 
	LcUserFacingExperience 를 상속받은 DA_ExamplePlaylist 는 DataAsset 으로 만들었지만 Experience 는 블루 프린트로 만들어야합니다. 
	블루프린트생성할때 LcExperienceDefinition 를 상속받아 만들어 줍니다. 이름은 B_LyraDefaultExperience 라고 하겠습니다. 열어보면 설정할 수 있는 변수가 Default Pawn Data 가 있습니다. 
	B_LyraDefaultExperience 를 DA_ExamplePlaylist 에서 스캔하려면 다시 프로젝트 세팅의 에셋매니저에서 스캔할 프라이머리 에셋 타입을 하나 추가해 프라이머리 에셋 타입 에셋 베이스 클래스 
	둘다 LcExperienceDefinition 으로 설정해줍니다. 그리고 그 밑에 블루프린트 클래스 보유 옵션을 활성화 합니다. 그리고 나서 언리얼 에디터를 재 실행한 후 디렉터리를 B_LyraDefaultExperience가
	위치한 System/Experiences 로 설정하면 이제 DA_ExamplePlaylist의 ExperienceId 에 스캔이 됩니다. 
	/* 저의 경우 스캔이 안됐었는데 왜냐면 LcUserFacingExperience.h 파일에서 ExperienceId 를 선언할때 UPROPERTY 의 인자중에 meta allowtype을 오타를 내서 인식이 안됐습니다. */
	
	이제 정리하자면 DA_ExamplePlaylist 라는 이름으로 UserFacingExperience 가 있고 이 안에서 MapId 로 L_DefaultEditorOverview 를 스캔해 넣고 ExperienceId 로 B_LyraDefaultExperience 
	를 스캔해 넣었습니다. 

	Content/System/DefaultEditormap 에 B_ExperienceList3D 라는 블루프린트가 있는데 이 블루프린트의 역할은 DA_ExamplePlaylist 라고 만들었던 UserFacingExperience 이것들이 몇개나 있는지
	보고 그만큼을 맵에 소환해 줄겁니다. 지금은 한개 밖에 없는데 더 많아 지면 그 숫자 만큼 소환을 해줄겁니다. 
	변수를 추가할건데 LcUserFacingExperience 를 리스트 형식으로 추가해서 UserFacingExperienceList 라는 이름의 변수로 들고 있을 겁니다. 그리고 Float 타입으로 PortalSpacing 이라고 들고 있겠습니다.
	UserFacingExperienceList는 DA_ExamplePlaylist 같은 Experience 들을 담아두는 배열이고 PortalSpacing은 각 포탈간의 간격을 말합니다. PortalSpacing 값은 500.0f 로 설정하겠습니다. 

	B_ExperienceList3D 에서 가장먼저 할 건 프로젝트가 가지고 있는 Experience 들을 다 가져와 UserFacingExperienceList 에 담아놔야 이후 관리를 시작할겁니다. 
	그 전에 혹시 남아 있을 쓰레기 값을 다 비워주고 시작하면 좋겠습니다. 블루프린트의 BeginPlay 에서 UserFacingExperienceList 의 Clear 노드를 연결해 밀어줍니다. 
	다음 노드로 Get Primary Asset Id List 라는 노드를 호출할겁니다. 이 함수는 Map, LcExperienceDefinition, PrimaryAssetLabel 카테고리를 골라 그에 해당하는 파일들을 다 긁어옵니다. 
	이 카테고리들은 프로젝트 세팅 -> 에셋 매니저 에서 스캔하기 위해 추가했던 카테고리들입니다. 

	여기서 이 카테고리중 우리가 추가하고 싶었던 LcUserFacingExperience 은 없는걸 알 수 있는데 이제는 자연스럽게 스캔하도록 카테고리를 추가하면 됩니다. 
	이제 Get Primary Asset Id List 함수에 LcUserFacingExperience 가 뜨는걸 볼 수 있는데 여기까지는 로딩까지 진행한게 아니라 스캔까지만 진행된겁니다. 
	로딩을 해줄겁니다. 

	로딩함수는 Async Load Primary Asset List 입니다. Async 는 비동기 방식이라는건데 비동기 방식은 함수가 완료되는걸 기다리지 않고 따로 코드 진행이 된다는 뜻이었습니다. 
	그래서 이 함수 노드에는 Complete 라는 화살표가 있는게 따로 함수가 완료되면 진행되는 화살표인겁니다. 
	Complete 가 되면 이어서 Foreach Loop 를 하면서 가져온 LcUserFacingExperience 들을 모두 로딩해 가져올거고 이어서 LcUserFacingExperience 로 캐스팅하고 UserFacingExperienceList 에 담아줍니다.

	리스트를 다 채운 후에는 이제 그 Experience 들을 포탈로 만들어줘야합니다. 스캔하고 로딩한 후의 for each 문의 complete 화살표를 이어서 진행하면 리스팅이 다 끝난 후의 코드입니다. 
	여기서 다시 UserFacingExperienceList 를 대상으로 foreach 를 돕니다. 

	그리고 생성할 포탈 액터를 만들어줘야하는데 액터를 상속받아서 이름을 B_TeleportToUserFacingExperience 라고 짓겠습니다. 안에서 스태틱 메쉬와 캡슐 콜리전을 추가해줍니다. 
	여기서 에셋이 필요하기 때문에 라이라 프로젝트에서 가져옵니다. B_TeleportToUserFacingExperience 를 검색해보면 블루프린트가 나오고 여기서 이중에 발판만 Lc 프로젝트에 이주해 오겠습니다. 

	에셋을 이주해 온 뒤 한번 에디터를 껏다 켜야할겁니다. 
	재부팅하고 난 뒤엔 B_TeleportToUserFacingExperience에서 추가해 뒀던 Static Mesh 를 이주해온 메쉬로 설정하고 캡슐 콜리전은 Location을 (0, 0, 100) 으로 설정하고 
	셰이프의 높이 너비를 80씩으로 설정합니다. 
	그리고 변수를 하나 가지고 있어야하는데 UserFacingExperience 를 가지고 있어야합니다. 포탈이 UserFacingExperience 을 가지고 있어야 이 포탈에 부딛힌 캐릭터를 해당 Experience로 보낼 수 
	있기 때문입니다. 이때 변수 옆에 눈 모양을 띄워줘야 c++에서 public 으로 만드는것과 같이 외부에서 수정할 수 있습니다. 그리고 디테일즈에서 이 변수를 스폰시 노출하도록 설정합니다.

	돌아와서 B_ExperienceList3D 에서 다시 변수를 하나 추가합니다. 포탈들을 리스트로 관리하겠습니다. 
	B_TeleportToUserFacingExperience 를 리스트 변수로 하나 만들고 아까 foreach 를 돌면서 매 시행마다 B_TeleportToUserFacingExperience 액터를 스폰한 후 로드했던 Experience를 추가해줍니다. 
	B_TeleportToUserFacingExperience 를 스폰할때 그 위치를 지정해줘야합니다. 적절한 로직으로 맵중앙으로 부터 UserFacingExperience 가 늘어 날때 마다 좌우로 위치하도록 만들어 Location 값을 
	SpawnActor 에 넘겨주면 됩니다. 
}

# 7 Experience Load
{
	맵을 만들고 Experience 의 뼈대를 만들어 그 포탈을 스폰하는 것까지는 했습니다. 
	이어서 Experience 를 로드 하는 내용을 알아 보겠습니다. 

	이전에 라이라 프로젝트에서는 하나의 게임모드를 계속 사용하고 그 안에서 Experience 라는 가벼운 모드를 가지고 전환하면서 실행된다고 했는데 
	그런데 사실은 여기에 더해 GameState, PlayerState, PlayerController, Character 이런것들 까지 만들어 놓고 시작합니다. 
	
	이 네가지들도 기본이 되는 개념들을 박아두고 안변하는 대신에 그 아래로 각각 필요한 부품들을 갈아 끼웁니다. 

	GameState 라는것은 GameMode 와 1대1 대응이 되고 그 부품으로 ExperienceManagerComponent 를 가지고 있으면서 이 컴포넌트가 로딩을 담당하고 
	로딩이 끝나면 응답을 해서 로딩이 끝났으니 다음 코드로 진행하라고 신호를 줍니다. 
	Experience 의 경우 원래 C++ 에 포함된 개념이 아니다 보니 그 흐름을 제어하기가 힘든데 이 ExperienceManagerComponent 에서 직접 로딩과 그 후 진행까지 
	맡아주는겁니다. 

	PlayerState 에서는 안에 PawnData를 캐싱해둘 건데 이 안에는 당연히 있어야 할 정보들이 있습니다. 어떤 폰을 스폰할지나 인풋은 어떻게 할지 그리고 카메라 모드같은것도 가지고 있습니다. 
	카메라 모드가 뭔가하면 보통 언리얼엔진을 배울때 플레이어 캐릭터에는 로컬 좌표로부터 일정거리를 뜻하는 스프링 암 개념이 있고 여기에 카메라를 아래로 붙여서 카메라를 달고 다녔습니다.
	그런데 라이라에서는 스프링 암이라는 개념이 없습니다. 
	카메라 모드가 대신하는데 지금 저격수 카메라 모드, 일반 카메라 모드, 공중 카메라 모드 등 을 사용해 카메라 형식을 바꿉니다. 

	PlayerController는 아래로 CameraManager 가 있습니다. CameraManager 와 Player가 들고 있던 CameraComponent 는 연관이 있습니다. 
	카메라 컴포넌트를 통해 화면을 보는데 렌더링은 카메라 매니저에서 렌더링을 해줍니다. 
	왜 이렇게 되어있냐면 라이라에서 캐릭터가 모두 플레이어는 아니기 때문입니다. 라이라에서 캐릭터는 동물이나 몬스터 엔피씨 일 수도 있는데 컨트롤러는 플레이어한테만 붙을 것이기 때문입니다. 

	그래서 이렇게 GameState, PlayerState, PlayerController, Character 네가지를 만들어보겠습니다. 

	기본 C++ 파일들 부터 만들겠습니다. Character 는 언리얼에디터에서 C++ 파일 추가로 Character 를 상속받아 LcCharacter 정도로 만들면 됩니다 생성 경로는 Source/Lc5_5/Character로 설정합니다.
	GameState는 GameStatebase 를 상속받고 GameMode 디렉터리로 설정합니다. PlayerController는 PlayerController 를 상속받고 Source/Lc5_5/Player 디렉토리를 만들고 거기로 생성하게 설정해줍니다.
	PlayerState 도 역시 PlayerState를 상속받고 Player 디렉토리 아래로 생성합니다. 

	다음은 LcGameModeBase 코드로 가서 생성자를 만들어 주고 생성자에서 초기화를 몇가지 해줄겁니다. 
	
	ALcGameModeBase::ALcGameModeBase()
	{
		GameStateClass = ALcGameState::StaticClass();
		PlayerControllerClass = ALcPlayerController::StaticClass();
		PlayerStateClass = ALcPlayerState::StaticClass();
		DefaultPawnClass = ALcCharacter::StaticClass();
	}
	이전에 언리얼 에디터에서 기본 게임모드를 LcGameModeBase 로 설정을 했었는데 그 내부의 기본 GameState,PlayerController,PlayerState,DefaultPawn 들을 지금 설정한 클래스들로 기본설정이 됩니다.
	실제로 에디터를 실행해서 프로젝트 설정->맵&모드 를 가보면 지금 설정한 클래스로 바뀌어있습니다. 라이라 프로젝트에서는 이렇게 시작을 합니다. 

	그러면 이제 의문이 생기는데 Experience 로 여러 게임들을 변경하는게 라이라 프로젝트였는데 지금처럼 기본 클래스들을 고정으로 박아두고 시작하면 어떻게 Experience 에 따라 변경할지가 궁금해집니다. 

	언리얼엔진이 실행되는 과정을 보면 GameInstance 가 가장 먼저 생성이 되고 World 만든 후에 Level, GameMode 순으로 생성이 됩니다. 각 모듈이 생성되는 순서 말고 호출되는 함수도 순서가 있는데 
	InitializeActorForPlay->InitGame 이라는 함수들을 가장 먼저 호출합니다. 아직 월드에 액터들을 스폰하기도 전입니다. 이 InitGame 함수를 오버라이드로 GameMode에 받아서 몇가지 초기화를 하겠습니다. 

	LcGameModeBase 클래스 안에 	
	virtual void InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage) override;
	이런 시그니처로 멤버 함수를 만들고 안에 
	Super::InitGame(MapName, Options, ErrorMessage);
	이 슈퍼 함수를 호출해주면 일단 오버라이딩 준비가 되었습니다. 여기에 추가로 새 함수를 만들어 호출할건데 그 함수 이름은 
	void HandleMatchAssignmentIfNotExpectingOne();
	입니다. 
	이 함수의 역할은 우리가 라이라 게임 만들면서 포탈을 타는 방식으로건 어떻게든 Experience를 선택하게 되는데 선택한 Experience 를 ExperienceManager 에서 로딩을 시작할겁니다. 
	이때 로딩뿐만 아니라 데디케이트 서버가 맞는지, 개발자의 옵션 설정인지 등등 여러가지 요소들을 전부 검사해서 매치를 해줍니다. 그래서 함수 이름이 HandleMatchAssignmentIfNotExpectingOne
	인겁니다. 
	하지만 제가 만들 프로젝트에서는 그냥 ExperienceLoading 을 선택하는 용도로만 쓸거기 때문에 조금 다르지만 일단은 기존 라이라 프로젝트를 따라 만들것이기 때문에 이 이름을 사용합니다.

	그러면 HandleMatchAssignmentIfNotExpectingOne 과 함께 호출할 ExperienceLoading 을 언제 진행할것인가를 생각해보면 바로 InitGame 에서 호출해줄겁니다. 

	void ALcGameModeBase::InitGame(const FString& MapName, const FString& Options, FString& ErrorMessage)
	{
		Super::InitGame(MapName, Options, ErrorMessage);

		// 아직 GameInstance를 통해, 초기화 작업이 진행되므로, 현 프레임에는 Lyra의 Concept인 Experience 처리를 진행할 수 없다:
		// - 이를 처리하기 위해, 한프레임 뒤에 이벤트를 받아 처리를 이어서 진행한다
		GetWorld()->GetTimerManager().SetTimerForNextTick(this, &ThisClass::HandleMatchAssignmentIfNotExpectingOne);
	}
	보면 World 를 가져오고 또 거기서 TimerManager의 SetTimerForNextTick 함수에서 HandleMatchAssignmentIfNotExpectingOne 를 호출하고 있습니다. SetTimerForNextTick 라는 함수가 무슨 함수나면
	지금 말고 다음 프레임때에 인자로 준 함수를 실행해달라는겁니다. 
	왜 굳이 다음 프레임에 실행하도록 했냐면 다시 언리얼엔진의 요소들이 로딩되는 순서를 봐야하는데 InitGame 이라는 함수가 엔진의 굉장히 초기에 호출된다고 했었습니다.
	그러다 보니 첫프레임 시점의 InitGame 에서는 다른 요소들이 거의 없습니다. 그리고 우리가 하려고 했던것도 Experience 로딩인데 이건 ExperienceManager 에서 로딩한다고 했는데 당연히 
	첫프레임 InitGame 에는 아직 객체가 생성되지 않았습니다. 그래서 SetTimerForNextTick 로 한 프레임 다음에 로딩을 해주는겁니다. 

	막상 아직 ExperienceManager를 만들지 않았습니다. 그러기 위해서 엔진을 실행한 후 몇가지 설정을 해야합니다. ExperienceManager 라는 것은 GameStateComponent 가 필요합니다. 
	이건 플러그인을 추가해야하는데 위의 옵션중에 프로젝트 세팅 밑에 플러그인을 관리하는 옵션이 있습니다.
	여기서 Modular Gameplay 를 활성화 시킵니다. 그리고 지금은 아닌데 나중에 프로젝트에 필요한 Game Features 플러그인도 지금 활성화 시키겠습니다. 마지막으로 Gameplay Abilities 까지 
	활성화를 해주면 되겠습니다. 

	플러그인을 추가하고 또 LC_5_5.bulid.cs 파일의 코드를 수정해야 우리가 C++ 로도 관리 할 수 있습니다. 

	PublicDependencyModuleNames.AddRange(new string[]  {
		"Core",
		"CoreUObject",
		"Engine",
		"InputCore",
		// GAS
		"GameplayTags",
		// Game Features
		"ModularGameplay",
		"GameFeatures",
	});
	
	이러고 나서 다시 엔진을 실행시켜봅니다. 

	C++ 클래스를 추가하는데 GameStateComponent 를 상속받게끔 해주고 이름을 LcExperienceManagerComponent 라고 짓습니다. 그리고 GameModes 폴더에 생성합니다. 
	이게 ExperienceManager 가 되는겁니다. 

	GameStateComponent는 어떤 것에 부착할 수 있게 해줍니다. 코드를 상위 클래스로 따라 올라가다 보면 UActorComponent 이것도 엑터에 부착할 수 있는 컴포넌트입니다. 
	GameState 에 추가로 붙힐 수 있는 Component 라서 GameStateComponent 입니다. 

	이런 컴포넌트 개념은 언리얼보다는 유니티 엔진에서 더 많이 사용하는 개념인데 이걸 GameFeatures 모듈로 가능하도록 만든겁니다. 이 구조의 장점은 확장성이 좋고 
	단점은 디버깅이 힘들고 파일이 많아서 가독성이 떨어진다는겁니다. 

	ExperienceManagerComponent는 GameStateComponent 이기 때문에 당연히 GameState에서 들고 있을겁니다. 우리가 만든 LcGameState 에서 들고 있을겁니다. 
	LcGameState 에서 LcExperienceManagerComponent 를 TObjectPtr 로 들고 있고 GameState 의 생성자에서 CreateDefaultSubobject 로 객체를 생성해줍니다. 

	이제 GameState에 컴포넌트를 부착은 했는데 아무런 설정을 하지 않았습니다. 

	LcExperienceManagerComponent 가 뭘 들고 있을지를 생각해보면 이 클래스가 할 일은 Experience를 로딩하는 클래스이다 보니 로딩할 클래스를 들고 있을겁니다. 
	이때 Experience를 들고 있다고 해서 로딩이 완료 되었다는 뜻은 아닙니다. 이 로딩이 완료되는 시점을 알아야 해당 Experience로 전환을 하는데 완성시점을 알려주는 C++ 문법이 
	델리게이트 입니다. 

	LcExperienceManagerComponent.h 파일 위쪽에 현재 가지고 있는 Experience의 로딩 상태를 enum class 를 선언합니다. 
	enum class ELcExperienceLoadState
	{
		Unloaded,
		Loading,
		Loaded,
		Deactivating,
	};

	그리고 Delegate를 언리얼에서 하는방법은 
	DECLARE_MULTICAST_DELEGATE_OneParam(FOnLcExperienceLoaded, const ULcExperienceDefinition*);
	이 매크로로 하나의 매개변수를 가지는 멀티캐스트 델리게이트를 선언합니다. 매개변수는 아까 만들었던 LcExperienceManagerComponent 가 들고 있을 Experience 입니다. 
	첫번째 인자로 준 FOnLcExperienceLoaded 는 이제 const ULcExperienceDefinition* 를 인자로 받는 멀티캐스트 델리게이트 클래스로 선언이 된겁니다. 

	그래서 이제 총 세가지 멤버 변수를 들고 있을 겁니다. 첫째로 로딩할 현재 Experience, 두번째로 Experience 가 현재 어떤 상태인지를 나타내는 ELcExperienceLoadState,
	세번째는 Experience 를 델리게이트할 FOnLcExperienceLoaded 입니다.

	public:
	UPROPERTY()
	TObjectPtr<const ULcExperienceDefinition> CurrentExperience;

	/** Experience의 로딩 상태를 모니터링 */
	ELcExperienceLoadState LoadState = ELcExperienceLoadState::Unloaded;

	/** Experience 로딩이 완료된 이후, Broadcasting Delegate */
	FOnLcExperienceLoaded OnExperienceLoaded;

	이제 함수를 하나 만들겁니다. 

	bool IsExperienceLoaded() { return (LoadState == ELcExperienceLoadState::Loaded) && (CurrentExperience != nullptr); }
	이 함수는 지금 Experience 가 로딩이 됐는지를 체크하는 함수인데 LoadState 가 Loaded 이고 CurrentExperience가 nullptr 이 아닌지를 체크 해주는겁니다. 
	
	또 한가지 함수를 더 만들건데
	void CallOrRegister_OnExperienceLoaded(FOnLcExperienceLoaded::FDelegate&& Delegate);
	이 함수는 델리게이트를 걸어주는 함수입니다. 

	사실 델리게이트는 아까 만든 델리게이트 객체에 델리게이트를 추가해주면 로딩이 됩니다. 무슨 말이냐면 
	OnExperienceLoaded.Add(Delegate);
	이렇게 해주면 끝인데 굳이 하나 더 래핑해서 사용할까요
	
	void ULcExperienceManagerComponent::CallOrRegister_OnExperienceLoaded(FOnLcExperienceLoaded::FDelegate&& Delegate)
	{
		// IsExperienceLoaded() 구현
		if (IsExperienceLoaded())
		{
			Delegate.Execute(CurrentExperience);
		}
		else
		{
			/**
			* 참고로, 여러분들은 Delegate 객체를 자세히 살펴보면, 내부적으로 필요한 변수들은 메모리 할당해놓는다:
			* TArray<int> a = {1, 2, 3, 4};
			* delegate_type delegate = [a](){
			*	return a.Num();
			* }
			* a는 delegate_type 내부에 new로 할당되어 있다. 복사 비용을 낮추기 위해 Move를 통해 하는 것을 잊지 말자!
			*/
			OnExperienceLoaded.Add(MoveTemp(Delegate));
		}
	}
	이런 코드인데 살펴보면 일단 Experience 가 로드된 상태인지를 체크해 로드 되어있으면 바로 Delegate.Excute(CurrentExperience); 를 호출해주고 
	만약 로드가 안되어 있다면 그러면 그때 델리게이트에 추가를 해주는겁니다. 
	그냥 무분별적으로 델리게이트에 추가하는게 아니라 로딩 여부를 한번 체크해 걸러주는겁니다. 

}